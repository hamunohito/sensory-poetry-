<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>感覚の詩 ARメーカー v2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background-color: #f8f9fa;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #header {
            padding: 20px;
            background-color: #ffffff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }

        #header h1 {
            font-size: 24px;
            color: #2d3748;
            margin: 0;
        }

        #header p {
            margin: 8px 0 0 0;
            font-size: 14px;
            color: #718096;
        }

        #mainContent {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 40vh;
            min-height: 250px;
            background-color: #f0f0f0;
        }

        #controls {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background-color: #ffffff;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 16px;
            color: #2d3748;
        }

        .control-group input[type="text"],
        .control-group select {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
        }

        .control-group input[type="color"] {
            width: 100%;
            height: 50px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 40px;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .preset-btn {
            padding: 10px;
            font-size: 14px;
            background-color: #edf2f7;
            color: #2d3748;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .preset-btn:active, .preset-btn.active {
            background-color: #4299e1;
            color: #ffffff;
        }

        #exportBtn, #exportStaticBtn {
            width: 100%;
            padding: 16px;
            font-size: 18px;
            font-weight: bold;
            background-color: #48bb78;
            color: #ffffff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 10px;
        }

        #exportStaticBtn {
            background-color: #4299e1;
        }

        #exportBtn:disabled, #exportStaticBtn:disabled {
            background-color: #cbd5e0;
            cursor: not-allowed;
        }

        .info-box {
            padding: 16px;
            background-color: #edf2f7;
            border-radius: 8px;
            font-size: 14px;
            color: #4a5568;
            line-height: 1.6;
        }

        .info-box p {
            margin: 0 0 8px 0;
            font-weight: bold;
        }

        .info-box ol {
            margin: 0;
            padding-left: 20px;
        }

        .info-box li {
            margin-bottom: 4px;
        }

        .status-message {
            padding: 12px;
            margin-top: 10px;
            background-color: #fed7d7;
            color: #742a2a;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .status-message.success {
            background-color: #c6f6d5;
            color: #22543d;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>感覚の詩 ARメーカー v2</h1>
            <p>オノマトペから3Dモデルとアニメーションをつくろう</p>
        </div>

        <div id="mainContent">
            <div id="canvas-container"></div>

            <div id="controls">
                <!-- プリセット -->
                <div class="control-group">
                    <label>プリセット</label>
                    <div class="preset-buttons">
                        <button class="preset-btn" data-preset="0">ぴょんぴょん</button>
                        <button class="preset-btn" data-preset="1">ぐるぐる</button>
                        <button class="preset-btn" data-preset="2">ふわふわ</button>
                        <button class="preset-btn" data-preset="3">ぷるぷる</button>
                        <button class="preset-btn" data-preset="4">きらきら</button>
                        <button class="preset-btn" data-preset="5">どんどん</button>
                        <button class="preset-btn" data-preset="6">ゆらゆら</button>
                        <button class="preset-btn" data-preset="7">びよんびよん</button>
                        <button class="preset-btn" data-preset="8">ひらひら</button>
                        <button class="preset-btn" data-preset="9">すーっ</button>
                        <button class="preset-btn" data-preset="10">ちかちか</button>
                        <button class="preset-btn" data-preset="11">くるくるのぼる</button>
                        <button class="preset-btn" data-preset="12">ころころ</button>
                        <button class="preset-btn" data-preset="13">ばーん</button>
                        <button class="preset-btn" data-preset="14">ぐらぐら</button>
                        <button class="preset-btn" data-preset="15">ぶるぶる</button>
                        <button class="preset-btn" data-preset="16">くねくね</button>
                        <button class="preset-btn" data-preset="17">るんるん</button>
                    </div>
                </div>

                <!-- 形状 -->
                <div class="control-group">
                    <label for="shape">形</label>
                    <select id="shape">
                        <option value="sphere">球</option>
                        <option value="box">立方体</option>
                        <option value="cylinder">円柱</option>
                        <option value="cone">円錐</option>
                        <option value="octahedron">八面体</option>
                        <option value="torus">ドーナツ</option>
                        <option value="star">星</option>
                        <option value="capsule">カプセル</option>
                        <option value="plane">平面</option>
                        <option value="ring">リング</option>
                        <option value="pyramid">ピラミッド</option>
                        <option value="diamond">ダイヤモンド</option>
                        <option value="prism">三角柱</option>
                        <option value="drop">水滴</option>
                        <option value="heart">ハート</option>
                        <option value="cross">十字</option>
                        <option value="crescent">三日月</option>
                        <option value="helix">螺旋</option>
                        <option value="cloud">雲</option>
                        <option value="flower">花</option>
                    </select>
                </div>

                <!-- 色 -->
                <div class="control-group">
                    <label for="color">色</label>
                    <input type="color" id="color" value="#ff6b6b">
                </div>

                <!-- アニメーション -->
                <div class="control-group">
                    <label for="animation">動き</label>
                    <select id="animation">
                        <option value="bounce">跳ねる (ぴょんぴょん)</option>
                        <option value="rotate">回る (ぐるぐる)</option>
                        <option value="float">浮遊 (ふわふわ)</option>
                        <option value="shake">震える (ぷるぷる)</option>
                        <option value="sparkle">きらめき (きらきら)</option>
                        <option value="pulse">脈打つ (どんどん)</option>
                        <option value="wave">波打つ (ゆらゆら)</option>
                        <option value="spiral">螺旋上昇 (くるくるのぼる)</option>
                        <option value="zigzag">ジグザグ (ぎざぎざ)</option>
                        <option value="stretch">伸縮 (びよんびよん)</option>
                        <option value="swing">揺れる (ゆらゆら)</option>
                        <option value="blink">点滅 (ちかちか)</option>
                        <option value="slide">スライド (すーっ)</option>
                        <option value="spin_bounce">回転ジャンプ (ぴょんくるくる)</option>
                        <option value="flutter">ひらひら (はたはた)</option>
                        <option value="circle">円を描く (ぐるっと)</option>
                        <option value="figure8">8の字 (くねくね)</option>
                        <option value="tumble">転がる (ころころ)</option>
                        <option value="explode">広がる (ばーん)</option>
                        <option value="implode">縮む (ぎゅー)</option>
                        <option value="wobble">ぐらぐら</option>
                        <option value="twist">ねじれる (ぎゅるぎゅる)</option>
                        <option value="orbit">周回 (まわる)</option>
                        <option value="vibrate">振動 (ぶるぶる)</option>
                        <option value="dance">踊る (るんるん)</option>
                    </select>
                </div>

                <!-- 速度 -->
                <div class="control-group">
                    <label for="speed">速さ: <span id="speedValue">1.0</span>x</label>
                    <input type="range" id="speed" min="0.5" max="3" step="0.1" value="1">
                </div>

                <!-- サイズ -->
                <div class="control-group">
                    <label for="size">大きさ: <span id="sizeValue">1.0</span></label>
                    <input type="range" id="size" min="0.5" max="2" step="0.1" value="1">
                </div>

                <!-- エクスポートボタン -->
                <button id="exportBtn">アニメーション付きGLBを保存</button>
                <button id="exportStaticBtn">静止GLBを保存（確実版）</button>
                
                <div id="statusMessage" class="status-message"></div>

                <!-- 使い方 -->
                <div class="info-box">
                    <p>使い方:</p>
                    <ol>
                        <li>プリセットを選ぶか、形・色・動きを自分で組み合わせる</li>
                        <li>速さと大きさを微調整</li>
                        <li>GLBファイルを保存（アニメーション付きまたは静止版）</li>
                        <li>palanAR (https://planar.jp/) にアップロード</li>
                        <li>QRコードを生成して、みんなで共有!</li>
                    </ol>
                    <p style="color: #e53e3e; margin-top: 10px;">
                        ※アニメーション付きGLBがうまく動かない場合は「静止GLBを保存」をお試しください
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Import Map for Three.js -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // Three.jsとGLTFExporterをインポート
        import * as THREE from 'three';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

        // グローバル変数
        let scene, camera, renderer, mesh, mixer, clock;
        let currentAnimation = null;
        let animationAction = null;

        // プリセット
        const presets = [
            { text: 'ぴょんぴょん', shape: 'sphere', color: '#ff6b6b', animation: 'bounce' },
            { text: 'ぐるぐる', shape: 'cylinder', color: '#4ecdc4', animation: 'rotate' },
            { text: 'ふわふわ', shape: 'cloud', color: '#ffe66d', animation: 'float' },
            { text: 'ぷるぷる', shape: 'sphere', color: '#a8dadc', animation: 'shake' },
            { text: 'きらきら', shape: 'star', color: '#ffd23f', animation: 'sparkle' },
            { text: 'どんどん', shape: 'box', color: '#ee6c4d', animation: 'pulse' },
            { text: 'ゆらゆら', shape: 'torus', color: '#95e1d3', animation: 'wave' },
            { text: 'びよんびよん', shape: 'capsule', color: '#f38181', animation: 'stretch' },
            { text: 'ひらひら', shape: 'plane', color: '#aa96da', animation: 'flutter' },
            { text: 'すーっ', shape: 'capsule', color: '#5dade2', animation: 'slide' },
            { text: 'ちかちか', shape: 'octahedron', color: '#f8b500', animation: 'blink' },
            { text: 'くるくるのぼる', shape: 'helix', color: '#48c9b0', animation: 'spiral' },
            { text: 'ころころ', shape: 'sphere', color: '#e74c3c', animation: 'tumble' },
            { text: 'ばーん', shape: 'star', color: '#ff5252', animation: 'explode' },
            { text: 'ぐらぐら', shape: 'pyramid', color: '#9575cd', animation: 'wobble' },
            { text: 'ぶるぶる', shape: 'drop', color: '#4fc3f7', animation: 'vibrate' },
            { text: 'くねくね', shape: 'helix', color: '#81c784', animation: 'figure8' },
            { text: 'るんるん', shape: 'heart', color: '#ff80ab', animation: 'dance' },
        ];

        // 初期化
        function init() {
            const container = document.getElementById('canvas-container');

            // シーン
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // カメラ
            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.z = 5;

            // レンダラー
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // ライト
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // クロック
            clock = new THREE.Clock();

            // リサイズ対応
            window.addEventListener('resize', onWindowResize);

            // 初期メッシュ作成
            updateMesh();

            // アニメーションループ
            animate();
        }

        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);

            if (mixer) {
                const delta = clock.getDelta();
                mixer.update(delta);
            }

            renderer.render(scene, camera);
        }

        // 星型ジオメトリ作成（修正版）
        function createStarGeometry(size) {
            const shape = new THREE.Shape();
            const points = 5;
            const outerRadius = size;
            const innerRadius = size * 0.4;

            for (let i = 0; i < points * 2; i++) {
                const angle = (Math.PI * 2 * i) / (points * 2) - Math.PI / 2;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                if (i === 0) {
                    shape.moveTo(x, y);
                } else {
                    shape.lineTo(x, y);
                }
            }
            shape.closePath();

            const extrudeSettings = {
                depth: size * 0.3,
                bevelEnabled: true,
                bevelSegments: 2,
                steps: 2,
                bevelSize: size * 0.05,
                bevelThickness: size * 0.05
            };

            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
        }

        // ピラミッド型
        function createPyramidGeometry(size) {
            return new THREE.ConeGeometry(size * 0.8, size * 1.2, 4);
        }

        // ダイヤモンド型（両錐）
        function createDiamondGeometry(size) {
            const geometry = new THREE.OctahedronGeometry(size * 0.8);
            geometry.scale(1, 1.5, 1); // Y方向に伸ばしてダイヤモンド型に
            return geometry;
        }

        // 水滴型（改善版）
        function createDropGeometry(size) {
            const geometry = new THREE.SphereGeometry(size * 0.7, 32, 32);
            // 上部を尖らせる
            const positions = geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                if (y > 0) {
                    const factor = 1 - (y / (size * 0.7)) * 0.5;
                    positions[i] *= factor;
                    positions[i + 2] *= factor;
                }
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
            return geometry;
        }

        // ハート型（シンプル版）
        function createHeartGeometry(size) {
            const heartShape = new THREE.Shape();
            const x = 0, y = 0;
            
            heartShape.moveTo( x + size * 0.25, y + size * 0.25 );
            heartShape.bezierCurveTo( x + size * 0.25, y + size * 0.25, x + size * 0.2, y, x, y );
            heartShape.bezierCurveTo( x - size * 0.3, y, x - size * 0.3, y + size * 0.35, x - size * 0.3, y + size * 0.35 );
            heartShape.bezierCurveTo( x - size * 0.3, y + size * 0.55, x - size * 0.1, y + size * 0.77, x + size * 0.25, y + size * 0.95 );
            heartShape.bezierCurveTo( x + size * 0.6, y + size * 0.77, x + size * 0.8, y + size * 0.55, x + size * 0.8, y + size * 0.35 );
            heartShape.bezierCurveTo( x + size * 0.8, y + size * 0.35, x + size * 0.8, y, x + size * 0.5, y );
            heartShape.bezierCurveTo( x + size * 0.35, y, x + size * 0.25, y + size * 0.25, x + size * 0.25, y + size * 0.25 );
            
            const extrudeSettings = {
                depth: size * 0.4,
                bevelEnabled: true,
                bevelSegments: 2,
                steps: 2,
                bevelSize: size * 0.02,
                bevelThickness: size * 0.02
            };

            const geometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
            geometry.center();
            return geometry;
        }

        // 十字型（修正版）
        function createCrossGeometry(size) {
            const shape = new THREE.Shape();
            const w = size * 0.3; // 十字の幅
            const l = size * 0.8; // 十字の長さ
            
            shape.moveTo(-w/2, -l);
            shape.lineTo(w/2, -l);
            shape.lineTo(w/2, -w/2);
            shape.lineTo(l, -w/2);
            shape.lineTo(l, w/2);
            shape.lineTo(w/2, w/2);
            shape.lineTo(w/2, l);
            shape.lineTo(-w/2, l);
            shape.lineTo(-w/2, w/2);
            shape.lineTo(-l, w/2);
            shape.lineTo(-l, -w/2);
            shape.lineTo(-w/2, -w/2);
            shape.closePath();

            const extrudeSettings = {
                depth: size * 0.2,
                bevelEnabled: false
            };

            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
        }

        // 三日月型
        function createCrescentGeometry(size) {
            return new THREE.TorusGeometry(size * 0.8, size * 0.3, 16, 32, Math.PI * 1.5);
        }

        // 螺旋型（修正版）
        function createHelixGeometry(size) {
            const points = [];
            for (let i = 0; i < 50; i++) {
                const t = i / 49;
                const angle = t * Math.PI * 4;
                const radius = size * 0.3;
                const height = (t - 0.5) * size * 2;
                points.push(new THREE.Vector3(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                ));
            }
            const curve = new THREE.CatmullRomCurve3(points);
            return new THREE.TubeGeometry(curve, 50, size * 0.1, 8, false);
        }

        // 雲型
        function createCloudGeometry(size) {
            const geometry = new THREE.SphereGeometry(size * 0.8, 32, 16);
            geometry.scale(1.5, 0.8, 1);
            return geometry;
        }

        // 花型
        function createFlowerGeometry(size) {
            return new THREE.DodecahedronGeometry(size * 0.8);
        }

        // リサイズ
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // メッシュ更新
        function updateMesh() {
            // 既存のメッシュを削除
            if (mesh) {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            }

            // パラメータ取得
            const shape = document.getElementById('shape').value;
            const color = document.getElementById('color').value;
            const size = parseFloat(document.getElementById('size').value);

            // ジオメトリ作成
            let geometry;
            try {
                switch (shape) {
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(size, 32, 32);
                        break;
                    case 'box':
                        geometry = new THREE.BoxGeometry(size, size, size);
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(size * 0.5, size * 0.5, size * 1.5, 32);
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(size * 0.7, size * 1.5, 32);
                        break;
                    case 'octahedron':
                        geometry = new THREE.OctahedronGeometry(size);
                        break;
                    case 'torus':
                        geometry = new THREE.TorusGeometry(size * 0.7, size * 0.3, 16, 100);
                        break;
                    case 'star':
                        geometry = createStarGeometry(size);
                        break;
                    case 'capsule':
                        geometry = new THREE.CapsuleGeometry(size * 0.3, size * 0.6, 4, 8);
                        break;
                    case 'plane':
                        geometry = new THREE.BoxGeometry(size * 1.5, size * 0.1, size * 1.5);
                        break;
                    case 'ring':
                        geometry = new THREE.TorusGeometry(size * 0.8, size * 0.1, 16, 100);
                        break;
                    case 'pyramid':
                        geometry = createPyramidGeometry(size);
                        break;
                    case 'diamond':
                        geometry = createDiamondGeometry(size);
                        break;
                    case 'prism':
                        geometry = new THREE.CylinderGeometry(size * 0.6, size * 0.6, size * 1.2, 3);
                        break;
                    case 'drop':
                        geometry = createDropGeometry(size);
                        break;
                    case 'heart':
                        geometry = createHeartGeometry(size);
                        break;
                    case 'cross':
                        geometry = createCrossGeometry(size);
                        break;
                    case 'crescent':
                        geometry = createCrescentGeometry(size);
                        break;
                    case 'helix':
                        geometry = createHelixGeometry(size);
                        break;
                    case 'cloud':
                        geometry = createCloudGeometry(size);
                        break;
                    case 'flower':
                        geometry = createFlowerGeometry(size);
                        break;
                    default:
                        geometry = new THREE.SphereGeometry(size, 32, 32);
                }
            } catch (error) {
                console.error('Geometry creation error:', error);
                geometry = new THREE.SphereGeometry(size, 32, 32);
            }

            // マテリアル作成
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.5,
                metalness: 0.2,
            });

            // メッシュ作成
            mesh = new THREE.Mesh(geometry, material);
            mesh.name = 'mesh';  // アニメーショントラックと一致させる
            scene.add(mesh);

            // アニメーション更新
            updateAnimation();
        }

        // アニメーション作成（改善版）
        function createAnimationClip(animType, duration) {
            const tracks = [];
            
            // キーフレーム時間を正規化（0から1の範囲）
            const times = [0, duration * 0.25, duration * 0.5, duration * 0.75, duration];
            
            switch (animType) {
                case 'bounce':
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        [0, duration * 0.5, duration],
                        [0, 0, 0, 0, 2, 0, 0, 0, 0],
                        THREE.InterpolateLinear
                    ));
                    break;
                
                case 'rotate':
                    const rotValues = [];
                    for (let i = 0; i <= 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                        rotValues.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack(
                        '.quaternion',
                        times,
                        rotValues,
                        THREE.InterpolateLinear
                    ));
                    break;

                case 'float':
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        [0, duration * 0.5, duration],
                        [0, -0.5, 0, 0, 0.5, 0, 0, -0.5, 0],
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'shake':
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        times,
                        [0, 0, 0, 0.2, 0, 0, -0.2, 0, 0, 0.2, 0, 0, 0, 0, 0],
                        THREE.InterpolateLinear
                    ));
                    break;

                case 'pulse':
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration * 0.5, duration],
                        [1, 1, 1, 1.5, 1.5, 1.5, 1, 1, 1],
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'sparkle':
                    const sparkleRotValues = [];
                    const sparkleScaleValues = [];
                    for (let i = 0; i <= 2; i++) {
                        const t = i / 2;
                        const angle = t * Math.PI;
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 0, 1), angle);
                        sparkleRotValues.push(q.x, q.y, q.z, q.w);
                        
                        const scale = i === 1 ? 1.3 : 1.0;
                        sparkleScaleValues.push(scale, scale, scale);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack(
                        '.quaternion',
                        [0, duration * 0.5, duration],
                        sparkleRotValues,
                        THREE.InterpolateLinear
                    ));
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration * 0.5, duration],
                        sparkleScaleValues,
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'wave':
                    const wavePositions = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const x = Math.sin(t * Math.PI * 2) * 0.5;
                        const y = Math.cos(t * Math.PI * 2) * 0.3;
                        wavePositions.push(x, y, 0);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        times,
                        wavePositions,
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'spiral':
                    const spiralPositions = [];
                    const spiralRotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const angle = t * Math.PI * 2;
                        const x = Math.cos(angle) * 1;
                        const z = Math.sin(angle) * 1;
                        const y = t * 2;
                        spiralPositions.push(x, y, z);
                        
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                        spiralRotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        times,
                        spiralPositions,
                        THREE.InterpolateSmooth
                    ));
                    tracks.push(new THREE.QuaternionKeyframeTrack(
                        '.quaternion',
                        times,
                        spiralRotations,
                        THREE.InterpolateLinear
                    ));
                    break;

                case 'zigzag':
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        times,
                        [0, 0, 0, 1, 0.5, 0, -1, 1, 0, 1, 1.5, 0, 0, 2, 0],
                        THREE.InterpolateLinear
                    ));
                    break;

                case 'stretch':
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration * 0.5, duration],
                        [1, 1, 1, 1, 2, 1, 1, 1, 1],
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'swing':
                    const swingRotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const angle = Math.sin(t * Math.PI * 2) * 0.5;
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 0, 1), angle);
                        swingRotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack(
                        '.quaternion',
                        times,
                        swingRotations,
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'blink':
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        times,
                        [1, 1, 1, 0.1, 0.1, 0.1, 1, 1, 1, 0.1, 0.1, 0.1, 1, 1, 1],
                        THREE.InterpolateLinear
                    ));
                    break;

                case 'slide':
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        [0, duration],
                        [-2, 0, 0, 2, 0, 0],
                        THREE.InterpolateLinear
                    ));
                    break;

                case 'spin_bounce':
                    const spinBouncePositions = [0, 0, 0, 0, 2, 0, 0, 0, 0];
                    const spinBounceRotations = [];
                    for (let i = 0; i <= 2; i++) {
                        const angle = (i / 2) * Math.PI * 2;
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                        spinBounceRotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        [0, duration * 0.5, duration],
                        spinBouncePositions,
                        THREE.InterpolateSmooth
                    ));
                    tracks.push(new THREE.QuaternionKeyframeTrack(
                        '.quaternion',
                        [0, duration * 0.5, duration],
                        spinBounceRotations,
                        THREE.InterpolateLinear
                    ));
                    break;

                case 'flutter':
                    const flutterPositions = [];
                    const flutterRotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const x = Math.sin(t * Math.PI * 2) * 0.3;
                        const y = Math.sin(t * Math.PI * 4) * 0.5;
                        flutterPositions.push(x, y, 0);
                        
                        const angle = Math.sin(t * Math.PI * 2) * 0.3;
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 0, 1), angle);
                        flutterRotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        times,
                        flutterPositions,
                        THREE.InterpolateSmooth
                    ));
                    tracks.push(new THREE.QuaternionKeyframeTrack(
                        '.quaternion',
                        times,
                        flutterRotations,
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'circle':
                    const circlePositions = [];
                    for (let i = 0; i <= 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const x = Math.cos(angle) * 1.5;
                        const z = Math.sin(angle) * 1.5;
                        circlePositions.push(x, 0, z);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        times,
                        circlePositions,
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'figure8':
                    const figure8Positions = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = (i / 4) * Math.PI * 2;
                        const x = Math.sin(t) * 1.5;
                        const y = Math.sin(t * 2) * 0.7;
                        figure8Positions.push(x, y, 0);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        times,
                        figure8Positions,
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'tumble':
                    const tumbleRotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const q = new THREE.Quaternion();
                        const angle1 = t * Math.PI * 2;
                        const angle2 = t * Math.PI * 2 * 0.7;
                        q.setFromEuler(new THREE.Euler(angle1, angle2, 0));
                        tumbleRotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack(
                        '.quaternion',
                        times,
                        tumbleRotations,
                        THREE.InterpolateLinear
                    ));
                    break;

                case 'explode':
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration * 0.7, duration],
                        [0.1, 0.1, 0.1, 2, 2, 2, 1.5, 1.5, 1.5],
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'implode':
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration * 0.7, duration],
                        [2, 2, 2, 0.1, 0.1, 0.1, 1, 1, 1],
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'wobble':
                    const wobbleRotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const wobbleX = Math.sin(t * Math.PI * 2) * 0.3;
                        const wobbleZ = Math.cos(t * Math.PI * 2) * 0.3;
                        const q = new THREE.Quaternion();
                        q.setFromEuler(new THREE.Euler(wobbleX, 0, wobbleZ));
                        wobbleRotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack(
                        '.quaternion',
                        times,
                        wobbleRotations,
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'twist':
                    const twistRotations = [];
                    const twistScales = [];
                    for (let i = 0; i <= 2; i++) {
                        const t = i / 2;
                        const angle = t * Math.PI;
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                        twistRotations.push(q.x, q.y, q.z, q.w);
                        
                        const scale = i === 1 ? 1.2 : 1.0;
                        twistScales.push(scale, 1.0, scale);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack(
                        '.quaternion',
                        [0, duration * 0.5, duration],
                        twistRotations,
                        THREE.InterpolateLinear
                    ));
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration * 0.5, duration],
                        twistScales,
                        THREE.InterpolateSmooth
                    ));
                    break;

                case 'orbit':
                    const orbitPositions = [];
                    const orbitRotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const x = Math.cos(angle) * 2;
                        const z = Math.sin(angle) * 1.5;
                        orbitPositions.push(x, 0, z);
                        
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                        orbitRotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        times,
                        orbitPositions,
                        THREE.InterpolateSmooth
                    ));
                    tracks.push(new THREE.QuaternionKeyframeTrack(
                        '.quaternion',
                        times,
                        orbitRotations,
                        THREE.InterpolateLinear
                    ));
                    break;

                case 'vibrate':
                    const vibratePositions = [];
                    for (let i = 0; i <= 10; i++) {
                        const offset = (i % 2 === 0) ? 0.1 : -0.1;
                        vibratePositions.push(offset, offset * 0.5, 0);
                    }
                    const vibrateTimes = [];
                    for (let i = 0; i <= 10; i++) {
                        vibrateTimes.push((i / 10) * duration);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        vibrateTimes,
                        vibratePositions,
                        THREE.InterpolateLinear
                    ));
                    break;

                case 'dance':
                    const dancePositions = [];
                    const danceRotations = [];
                    const danceScales = [];
                    for (let i = 0; i <= 5; i++) {
                        const t = i / 5;
                        const x = Math.sin(t * Math.PI * 2) * 0.5;
                        const y = Math.abs(Math.sin(t * Math.PI * 4)) * 0.8;
                        dancePositions.push(x, y, 0);
                        
                        const angle = Math.sin(t * Math.PI * 2) * 0.3;
                        const q = new THREE.Quaternion();
                        q.setFromEuler(new THREE.Euler(angle, angle * 0.5, angle * 0.3));
                        danceRotations.push(q.x, q.y, q.z, q.w);
                        
                        const scale = 1 + Math.sin(t * Math.PI * 4) * 0.1;
                        danceScales.push(scale, scale, scale);
                    }
                    const danceTimes = [0, duration * 0.2, duration * 0.4, duration * 0.6, duration * 0.8, duration];
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        danceTimes,
                        dancePositions,
                        THREE.InterpolateSmooth
                    ));
                    tracks.push(new THREE.QuaternionKeyframeTrack(
                        '.quaternion',
                        danceTimes,
                        danceRotations,
                        THREE.InterpolateSmooth
                    ));
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        danceTimes,
                        danceScales,
                        THREE.InterpolateSmooth
                    ));
                    break;

                // デフォルトは回転
                default:
                    const defaultRotValues = [];
                    for (let i = 0; i <= 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                        defaultRotValues.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack(
                        '.quaternion',
                        times,
                        defaultRotValues,
                        THREE.InterpolateLinear
                    ));
            }
            
            return new THREE.AnimationClip('animation', duration, tracks);
        }

        // アニメーション更新
        function updateAnimation() {
            if (!mesh) return;

            const animType = document.getElementById('animation').value;
            const speed = parseFloat(document.getElementById('speed').value);
            const duration = 2 / speed;

            // アニメーションクリップ作成
            currentAnimation = createAnimationClip(animType, duration);
            
            // ミキサー更新
            if (mixer) {
                mixer.stopAllAction();
                mixer.uncacheRoot(mesh);
            }
            
            mixer = new THREE.AnimationMixer(mesh);
            animationAction = mixer.clipAction(currentAnimation);
            animationAction.loop = THREE.LoopRepeat;
            animationAction.play();
        }

        // GLB書き出し（改善版）
        async function exportGLB(includeAnimation = true) {
            if (!mesh) {
                showStatus('3Dモデルが準備できていません。', false);
                return;
            }

            const exportBtn = includeAnimation 
                ? document.getElementById('exportBtn') 
                : document.getElementById('exportStaticBtn');
            
            exportBtn.disabled = true;
            exportBtn.textContent = 'エクスポート中...';

            try {
                // エクスポート用シーンを作成
                const exportScene = new THREE.Scene();
                
                // メッシュを完全に新規作成
                const exportMesh = new THREE.Mesh(
                    mesh.geometry.clone(),
                    mesh.material.clone()
                );
                exportMesh.name = 'mesh';  // 重要: アニメーションのターゲット名と一致させる
                
                // Transform初期化
                exportMesh.position.set(0, 0, 0);
                exportMesh.rotation.set(0, 0, 0);
                exportMesh.scale.set(1, 1, 1);
                exportMesh.updateMatrix();
                exportMesh.updateMatrixWorld();
                
                exportScene.add(exportMesh);

                // アニメーション付きの場合
                let animations = [];
                if (includeAnimation && currentAnimation) {
                    // アニメーションクリップを適切に設定
                    const clip = currentAnimation.clone();
                    clip.name = 'animation';
                    
                    // トラック名を修正（mesh.positionなどの形式に）
                    clip.tracks = clip.tracks.map(track => {
                        const newTrack = track.clone();
                        // トラック名が正しい形式になっているか確認
                        if (!newTrack.name.startsWith('mesh.')) {
                            newTrack.name = 'mesh.' + newTrack.name.replace(/^\./, '');
                        }
                        return newTrack;
                    });
                    
                    animations = [clip];
                    console.log('Animation prepared:', clip.name, 'Duration:', clip.duration, 'Tracks:', clip.tracks.length);
                }

                // GLTFExporter設定（palanAR互換性重視）
                const exportOptions = {
                    binary: true,
                    animations: animations,
                    forceIndices: true,
                    truncateDrawRange: false,
                    includeCustomExtensions: false
                };

                console.log('Export options:', exportOptions);

                const exporter = new GLTFExporter();
                
                // エクスポート実行
                exporter.parse(
                    exportScene,
                    function (result) {
                        try {
                            const byteLength = result.byteLength || new Blob([result]).size;
                            console.log('Export successful, size:', byteLength, 'bytes');
                            
                            // サイズチェック
                            if (byteLength < 5000 && includeAnimation) {
                                console.warn('File size seems too small for animated GLB');
                            }
                            
                            // Blobを作成してダウンロード
                            const blob = new Blob([result], { type: 'model/gltf-binary' });
                            const url = URL.createObjectURL(blob);
                            
                            const link = document.createElement('a');
                            link.href = url;
                            
                            const timestamp = new Date().toISOString()
                                .replace(/[:.]/g, '-')
                                .slice(0, 19);
                            const suffix = includeAnimation ? 'animated' : 'static';
                            link.download = `sensory-poetry-${suffix}-${timestamp}.glb`;
                            
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            
                            setTimeout(() => URL.revokeObjectURL(url), 1000);
                            
                            exportBtn.disabled = false;
                            exportBtn.textContent = includeAnimation 
                                ? 'アニメーション付きGLBを保存' 
                                : '静止GLBを保存（確実版）';
                            
                            const message = includeAnimation
                                ? 'アニメーション付きGLBファイルをダウンロードしました！\nファイルサイズ: ' + Math.round(byteLength / 1024) + 'KB'
                                : '静止GLBファイルをダウンロードしました！\nファイルサイズ: ' + Math.round(byteLength / 1024) + 'KB';
                            
                            showStatus(message, true);
                            
                            // 詳細なアラート
                            const detailMessage = includeAnimation
                                ? `アニメーション付きGLBファイルがダウンロードされました！
ファイルサイズ: ${Math.round(byteLength / 1024)}KB

【次のステップ】
1. palanAR (https://planar.jp/) にアクセス
2. 「ARマーカー作成」からファイルをアップロード
3. QRコードを生成して共有

※アニメーションが再生されない場合は「静止GLBを保存」をお試しください`
                                : `静止GLBファイルがダウンロードされました！
ファイルサイズ: ${Math.round(byteLength / 1024)}KB

【次のステップ】
1. palanAR (https://planar.jp/) にアクセス
2. 「ARマーカー作成」からファイルをアップロード
3. QRコードを生成して共有`;
                            
                            alert(detailMessage);
                            
                        } catch (e) {
                            console.error('Post-export error:', e);
                            exportBtn.disabled = false;
                            exportBtn.textContent = includeAnimation 
                                ? 'アニメーション付きGLBを保存' 
                                : '静止GLBを保存（確実版）';
                            showStatus('ファイル保存中にエラーが発生しました: ' + e.message, false);
                        }
                    },
                    function (error) {
                        console.error('Export error:', error);
                        exportBtn.disabled = false;
                        exportBtn.textContent = includeAnimation 
                            ? 'アニメーション付きGLBを保存' 
                            : '静止GLBを保存（確実版）';
                        showStatus('エクスポートに失敗しました: ' + (error.message || 'Unknown error'), false);
                    },
                    exportOptions
                );
            } catch (error) {
                console.error('Export exception:', error);
                exportBtn.disabled = false;
                exportBtn.textContent = includeAnimation 
                    ? 'アニメーション付きGLBを保存' 
                    : '静止GLBを保存（確実版）';
                showStatus('エクスポート処理でエラーが発生しました: ' + error.message, false);
            }
        }

        // ステータスメッセージ表示
        function showStatus(message, isSuccess) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = isSuccess ? 'status-message success' : 'status-message';
            statusEl.style.display = 'block';
            
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 5000);
        }

        // イベントリスナー
        document.getElementById('shape').addEventListener('change', updateMesh);
        document.getElementById('color').addEventListener('input', updateMesh);
        document.getElementById('animation').addEventListener('change', updateAnimation);
        document.getElementById('size').addEventListener('input', function() {
            document.getElementById('sizeValue').textContent = this.value;
            updateMesh();
        });
        document.getElementById('speed').addEventListener('input', function() {
            document.getElementById('speedValue').textContent = parseFloat(this.value).toFixed(1);
            updateAnimation();
        });

        // プリセットボタン
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const presetIndex = parseInt(this.dataset.preset);
                const preset = presets[presetIndex];
                
                document.getElementById('shape').value = preset.shape;
                document.getElementById('color').value = preset.color;
                document.getElementById('animation').value = preset.animation;
                
                // アクティブクラス
                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                updateMesh();
            });
        });

        // エクスポートボタン
        document.getElementById('exportBtn').addEventListener('click', () => exportGLB(true));
        document.getElementById('exportStaticBtn').addEventListener('click', () => exportGLB(false));

        // 初期化実行
        init();
    </script>
</body>
</html>