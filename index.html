<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ„Ÿè¦šã®è©© ARãƒ¡ãƒ¼ã‚«ãƒ¼ v5 - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆãƒ»PCç”¨ï¼šå·¦å³åˆ†å‰²ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        @media (min-width: 768px) {
            #mainContent {
                flex-direction: row !important;
            }
            
            #canvas-container {
                width: 60% !important;
                height: 100% !important;
                min-height: auto !important;
            }
            
            #controls {
                width: 40% !important;
                height: 100% !important;
            }
        }
        
        @media (min-width: 1024px) {
            #canvas-container {
                width: 65% !important;
            }
            
            #controls {
                width: 35% !important;
            }
        }
        
        @media (min-width: 1440px) {
            #canvas-container {
                width: 70% !important;
            }
            
            #controls {
                width: 30% !important;
            }
        }

        #header {
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            text-align: center;
        }

        #header h1 {
            font-size: 22px;
            color: #2d3748;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #header p {
            margin: 4px 0 0 0;
            font-size: 13px;
            color: #718096;
        }

        #mainContent {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 35vh;
            min-height: 200px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
        }

        #controls {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.95);
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
            font-size: 14px;
            color: #2d3748;
        }

        .control-group select {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background-color: #ffffff;
        }

        .control-group input[type="color"] {
            width: 100%;
            height: 45px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 35px;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
            padding: 5px;
            background-color: #f7fafc;
            border-radius: 8px;
        }

        .preset-btn {
            padding: 8px;
            font-size: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            opacity: 0.7;
        }

        .preset-btn:hover {
            opacity: 0.85;
            transform: scale(1.05);
        }

        .preset-btn.active {
            opacity: 1;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        #exportBtn, #exportZipBtn {
            width: 100%;
            padding: 14px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: #ffffff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 8px;
            transition: all 0.3s;
        }

        #exportZipBtn {
            background: linear-gradient(135deg, #9f7aea 0%, #805ad5 100%);
        }

        #exportBtn:hover, #exportZipBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        #exportBtn:disabled, #exportZipBtn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }

        .info-box {
            padding: 12px;
            background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
            border-radius: 8px;
            font-size: 12px;
            color: #4a5568;
            line-height: 1.5;
        }

        .info-box p {
            margin: 0 0 6px 0;
            font-weight: bold;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            padding: 10px;
            background-color: #f7fafc;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 11px;
            color: #718096;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>æ„Ÿè¦šã®è©© ARãƒ¡ãƒ¼ã‚«ãƒ¼ v5 - Enhanced</h1>
            <p>ç›´æ–¹ä½“ãƒ»ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´ãƒ»GLBã‚¤ãƒ³ãƒãƒ¼ãƒˆå¯¾å¿œ</p>
            <p>ã‚ªãƒãƒãƒˆãƒšã‹ã‚‰3Dãƒ¢ãƒ‡ãƒ«ã¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã¤ãã‚ã†</p>
        </div>

        <div id="mainContent">
            <div id="canvas-container"></div>

            <div id="controls">
                <!-- çµ±è¨ˆ -->
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value">40</div>
                        <div class="stat-label">å½¢ã®ç¨®é¡</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">45</div>
                        <div class="stat-label">å‹•ãã®ç¨®é¡</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">1800+</div>
                        <div class="stat-label">çµ„ã¿åˆã‚ã›</div>
                    </div>
                </div>

                <!-- ãƒ—ãƒªã‚»ãƒƒãƒˆ -->
                <div class="control-group">
                    <label>ãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆ30ç¨®é¡ï¼‰</label>
                    <div class="preset-buttons">
                        <button class="preset-btn" data-preset="0">ã´ã‚‡ã‚“ã´ã‚‡ã‚“</button>
                        <button class="preset-btn" data-preset="1">ãã‚‹ãã‚‹</button>
                        <button class="preset-btn" data-preset="2">ãµã‚ãµã‚</button>
                        <button class="preset-btn" data-preset="3">ã·ã‚‹ã·ã‚‹</button>
                        <button class="preset-btn" data-preset="4">ãã‚‰ãã‚‰</button>
                        <button class="preset-btn" data-preset="5">ã©ã‚“ã©ã‚“</button>
                        <button class="preset-btn" data-preset="6">ã‚†ã‚‰ã‚†ã‚‰</button>
                        <button class="preset-btn" data-preset="7">ã³ã‚ˆã‚“ã³ã‚ˆã‚“</button>
                        <button class="preset-btn" data-preset="8">ã²ã‚‰ã²ã‚‰</button>
                        <button class="preset-btn" data-preset="9">ã™ãƒ¼ã£</button>
                        <button class="preset-btn" data-preset="10">ã¡ã‹ã¡ã‹</button>
                        <button class="preset-btn" data-preset="11">ãã‚‹ãã‚‹ã®ã¼ã‚‹</button>
                        <button class="preset-btn" data-preset="12">ã“ã‚ã“ã‚</button>
                        <button class="preset-btn" data-preset="13">ã°ãƒ¼ã‚“</button>
                        <button class="preset-btn" data-preset="14">ãã‚‰ãã‚‰</button>
                        <button class="preset-btn" data-preset="15">ã¶ã‚‹ã¶ã‚‹</button>
                        <button class="preset-btn" data-preset="16">ãã­ãã­</button>
                        <button class="preset-btn" data-preset="17">ã‚‹ã‚“ã‚‹ã‚“</button>
                        <button class="preset-btn" data-preset="18">ã±ãŸã±ãŸ</button>
                        <button class="preset-btn" data-preset="19">ã«ã‚‡ãã«ã‚‡ã</button>
                        <button class="preset-btn" data-preset="20">ã—ã‚…ã‚ã—ã‚…ã‚</button>
                        <button class="preset-btn" data-preset="21">ã´ã‹ã´ã‹</button>
                        <button class="preset-btn" data-preset="22">ã©ãã©ã</button>
                        <button class="preset-btn" data-preset="23">ãµã‚Šãµã‚Š</button>
                        <button class="preset-btn" data-preset="24">ã²ã‚…ã‚‹ã²ã‚…ã‚‹</button>
                        <button class="preset-btn" data-preset="25">ã‚ã‚‰ã‚ã‚‰</button>
                        <button class="preset-btn" data-preset="26">ã–ã‚ã–ã‚</button>
                        <button class="preset-btn" data-preset="27">ã´ã‚Šã´ã‚Š</button>
                        <button class="preset-btn" data-preset="28">ã®ã³ã®ã³</button>
                        <button class="preset-btn" data-preset="29">ãã‚…ã‚“ãã‚…ã‚“</button>
                    </div>
                </div>

                <!-- GLBã‚¤ãƒ³ãƒãƒ¼ãƒˆ -->
                <div class="control-group" style="background-color: #edf2f7; padding: 15px; border-radius: 8px;">
                    <label for="glbImport" style="font-size: 14px;">ğŸ“ GLBãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</label>
                    <input type="file" id="glbImport" accept=".glb,.gltf" style="margin-top: 8px; font-size: 13px;" />
                    <button id="clearImport" style="margin-top: 8px; padding: 8px 12px; font-size: 12px; background: #e53e3e; color: white; border: none; border-radius: 6px; cursor: pointer;">ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢</button>
                    <div style="font-size: 12px; color: #718096; margin-top: 8px; line-height: 1.5;">
                        GLB/GLTFãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ç·¨é›†ã§ãã¾ã™ã€‚
                    </div>
                </div>

                <!-- å½¢çŠ¶ -->
                <div class="control-group">
                    <label for="shape">å½¢ï¼ˆ40ç¨®é¡ï¼‰</label>
                    <select id="shape">
                        <optgroup label="åŸºæœ¬å½¢çŠ¶">
                            <option value="sphere">çƒ</option>
                            <option value="box">ç«‹æ–¹ä½“</option>
                            <option value="cuboid">ç›´æ–¹ä½“</option>
                            <option value="cylinder">å††æŸ±</option>
                            <option value="cone">å††éŒ</option>
                            <option value="octahedron">å…«é¢ä½“</option>
                            <option value="torus">ãƒ‰ãƒ¼ãƒŠãƒ„</option>
                            <option value="plane">å¹³é¢</option>
                            <option value="ring">ãƒªãƒ³ã‚°</option>
                        </optgroup>
                        <optgroup label="ç‰¹æ®Šå½¢çŠ¶">
                            <option value="star">æ˜Ÿ</option>
                            <option value="heart">ãƒãƒ¼ãƒˆ</option>
                            <option value="diamond">ãƒ€ã‚¤ãƒ¤ãƒ¢ãƒ³ãƒ‰</option>
                            <option value="pyramid">ãƒ”ãƒ©ãƒŸãƒƒãƒ‰</option>
                            <option value="crystal">çµæ™¶</option>
                            <option value="cross">åå­—</option>
                            <option value="arrow">çŸ¢å°</option>
                            <option value="gear">æ­¯è»Š</option>
                        </optgroup>
                        <optgroup label="è‡ªç„¶å½¢çŠ¶">
                            <option value="drop">æ°´æ»´</option>
                            <option value="cloud">é›²</option>
                            <option value="flower">èŠ±</option>
                            <option value="crescent">ä¸‰æ—¥æœˆ</option>
                            <option value="snowflake">é›ªã®çµæ™¶</option>
                            <option value="egg">ãŸã¾ã”</option>
                            <option value="butterfly">è¶ã€…</option>
                            <option value="leaf">è‘‰ã£ã±</option>
                            <option value="lightning">ç¨²å¦»</option>
                            <option value="wave">æ³¢</option>
                            <option value="flame">ç‚</option>
                            <option value="mountain">å±±</option>
                        </optgroup>
                        <optgroup label="å¹¾ä½•å­¦å½¢çŠ¶">
                            <option value="tetrahedron">å››é¢ä½“</option>
                            <option value="icosahedron">äºŒåé¢ä½“</option>
                            <option value="knot">çµã³ç›®</option>
                            <option value="helix">èºæ—‹</option>
                            <option value="hexagon">å…­è§’æŸ±</option>
                            <option value="pentaprism">äº”è§’æŸ±</option>
                            <option value="capsule">ã‚«ãƒ—ã‚»ãƒ«</option>
                            <option value="prism">ä¸‰è§’æŸ±</option>
                        </optgroup>
                        <optgroup label="å®‡å®™ãƒ»å¤©ä½“">
                            <option value="sun">å¤ªé™½</option>
                            <option value="moon">ä¸‰æ—¥æœˆ</option>
                            <option value="rocket">ãƒ­ã‚±ãƒƒãƒˆ</option>
                            <option value="ufo">UFO</option>
                            <option value="alien">å®‡å®™äºº</option>
                        </optgroup>
                    </select>
                </div>

                <!-- è‰² -->
                <div class="control-group">
                    <label for="color">è‰²</label>
                    <input type="color" id="color" value="#ff6b6b">
                    <div style="margin-top: 8px;">
                        <label style="display: flex; align-items: center; font-weight: normal; font-size: 13px;">
                            <input type="checkbox" id="applyColorToImported" style="margin-right: 6px; width: auto; height: auto;">
                            ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ãŸãƒ¢ãƒ‡ãƒ«ã«è‰²ã‚’é©ç”¨ï¼ˆå…ƒã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒå¤±ã‚ã‚Œã¾ã™ï¼‰
                        </label>
                    </div>
                </div>

                <!-- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ -->
                <div class="control-group">
                    <label for="animation">å‹•ãï¼ˆ45ç¨®é¡ï¼‰</label>
                    <select id="animation">
                        <optgroup label="åŸºæœ¬ã®å‹•ã">
                            <option value="bounce">è·³ã­ã‚‹ (ã´ã‚‡ã‚“ã´ã‚‡ã‚“)</option>
                            <option value="rotate">å›ã‚‹ (ãã‚‹ãã‚‹)</option>
                            <option value="float">æµ®éŠ (ãµã‚ãµã‚)</option>
                            <option value="shake">éœ‡ãˆã‚‹ (ã·ã‚‹ã·ã‚‹)</option>
                            <option value="pulse">è„ˆæ‰“ã¤ (ã©ã‚“ã©ã‚“)</option>
                            <option value="wave">æ³¢æ‰“ã¤ (ã‚†ã‚‰ã‚†ã‚‰)</option>
                            <option value="swing">æºã‚Œã‚‹ (ã‚†ã‚‰ã‚†ã‚‰)</option>
                            <option value="slide">ã‚¹ãƒ©ã‚¤ãƒ‰ (ã™ãƒ¼ã£)</option>
                        </optgroup>
                        <optgroup label="ç‰¹æ®ŠåŠ¹æœ">
                            <option value="sparkle">ãã‚‰ã‚ã (ãã‚‰ãã‚‰)</option>
                            <option value="blink">ç‚¹æ»… (ã¡ã‹ã¡ã‹)</option>
                            <option value="flash">ç‚¹æ»…å¼·èª¿ (ã´ã‹ã´ã‹)</option>
                            <option value="explode">åºƒãŒã‚‹ (ã°ãƒ¼ã‚“)</option>
                            <option value="implode">ç¸®ã‚€ (ãã‚…ãƒ¼)</option>
                            <option value="teleport">ç¬é–“ç§»å‹• (ã—ã‚…ã£)</option>
                            <option value="electric">é›»æ°— (ã´ã‚Šã´ã‚Š)</option>
                            <option value="fire">ç‚ (ã‚ã‚‰ã‚ã‚‰)</option>
                        </optgroup>
                        <optgroup label="è¤‡é›‘ãªå‹•ã">
                            <option value="spiral">èºæ—‹ä¸Šæ˜‡ (ãã‚‹ãã‚‹ã®ã¼ã‚‹)</option>
                            <option value="zigzag">ã‚¸ã‚°ã‚¶ã‚° (ãã–ãã–)</option>
                            <option value="figure8">8ã®å­— (ãã­ãã­)</option>
                            <option value="circle">å††ã‚’æã (ãã‚‹ã£ã¨)</option>
                            <option value="orbit">å‘¨å› (ã¾ã‚ã‚‹)</option>
                            <option value="tornado">ç«œå·» (ãã‚‹ã‚“ãã‚‹ã‚“)</option>
                            <option value="pendulum">æŒ¯ã‚Šå­ (ã‚†ã‚‰ãƒ¼ã‚Š)</option>
                            <option value="spin_bounce">å›è»¢ã‚¸ãƒ£ãƒ³ãƒ— (ã´ã‚‡ã‚“ãã‚‹ãã‚‹)</option>
                        </optgroup>
                        <optgroup label="å¤‰å½¢ç³»">
                            <option value="stretch">ä¼¸ç¸® (ã³ã‚ˆã‚“ã³ã‚ˆã‚“)</option>
                            <option value="twist">ã­ã˜ã‚Œã‚‹ (ãã‚…ã‚‹ãã‚…ã‚‹)</option>
                            <option value="wobble">ãã‚‰ãã‚‰</option>
                            <option value="jello">ã‚¼ãƒªãƒ¼çŠ¶ (ã·ã‚‹ã‚“ã·ã‚‹ã‚“)</option>
                            <option value="grow">æˆé•· (ã«ã‚‡ãã«ã‚‡ã)</option>
                            <option value="shrink">ç¸®å° (ãã‚…ã‚“ãã‚…ã‚“)</option>
                            <option value="morph">å¤‰å½¢ (ã‚€ã«ã‚€ã«)</option>
                            <option value="expand">è†¨å¼µ (ã®ã³ã®ã³)</option>
                        </optgroup>
                        <optgroup label="ç”Ÿç‰©çš„ãªå‹•ã">
                            <option value="flap">ç¾½ã°ãŸã (ã±ãŸã±ãŸ)</option>
                            <option value="flutter">ã²ã‚‰ã²ã‚‰ (ã¯ãŸã¯ãŸ)</option>
                            <option value="tumble">è»¢ãŒã‚‹ (ã“ã‚ã“ã‚)</option>
                            <option value="dance">è¸Šã‚‹ (ã‚‹ã‚“ã‚‹ã‚“)</option>
                            <option value="heartbeat">å¿ƒè‡“ã®é¼“å‹• (ã©ãã©ã)</option>
                            <option value="sway">å·¦å³ã«æŒ¯ã‚‹ (ãµã‚Šãµã‚Š)</option>
                            <option value="snake">è›‡è¡Œ (ã«ã‚‡ã‚ã«ã‚‡ã‚)</option>
                            <option value="swim">æ³³ã (ã™ã„ã™ã„)</option>
                        </optgroup>
                        <optgroup label="ç’°å¢ƒåŠ¹æœ">
                            <option value="vibrate">æŒ¯å‹• (ã¶ã‚‹ã¶ã‚‹)</option>
                            <option value="bubble">æ³¡ç«‹ã¤ (ã—ã‚…ã‚ã—ã‚…ã‚)</option>
                            <option value="wind">é¢¨ (ã²ã‚…ã‚‹ã²ã‚…ã‚‹)</option>
                            <option value="crowd">ç¾¤ã‚Œ (ã–ã‚ã–ã‚)</option>
                            <option value="warm">æ¸©ã‹ã„ (ã½ã‹ã½ã‹)</option>
                        </optgroup>
                    </select>
                </div>

                <!-- é€Ÿåº¦ -->
                <div class="control-group">
                    <label for="speed">é€Ÿã•: <span id="speedValue">1.0</span>x</label>
                    <input type="range" id="speed" min="0.5" max="3" step="0.1" value="1">
                </div>

                <!-- ã‚µã‚¤ã‚º -->
                <div class="control-group">
                    <label for="size">å¤§ãã•: <span id="sizeValue">1.0</span></label>
                    <input type="range" id="size" min="0.5" max="2" step="0.1" value="1">
                </div>

                <!-- ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´ -->
                <div class="control-group">
                    <label>ğŸ“ å½¢çŠ¶ã®å¤‰å½¢ï¼ˆæ¨ªãƒ»ç¸¦ãƒ»é«˜ã•ï¼‰</label>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px;">
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <label style="font-size: 12px; margin-bottom: 5px; color: #4a5568;">æ¨ªå¹… (X)</label>
                            <input type="range" id="scaleX" min="0.5" max="3" step="0.1" value="1" style="width: 100%;">
                            <span id="scaleXValue" style="font-size: 11px; color: #718096; margin-top: 3px;">1.0</span>
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <label style="font-size: 12px; margin-bottom: 5px; color: #4a5568;">é«˜ã• (Y)</label>
                            <input type="range" id="scaleY" min="0.5" max="3" step="0.1" value="1" style="width: 100%;">
                            <span id="scaleYValue" style="font-size: 11px; color: #718096; margin-top: 3px;">1.0</span>
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <label style="font-size: 12px; margin-bottom: 5px; color: #4a5568;">å¥¥è¡Œ (Z)</label>
                            <input type="range" id="scaleZ" min="0.5" max="3" step="0.1" value="1" style="width: 100%;">
                            <span id="scaleZValue" style="font-size: 11px; color: #718096; margin-top: 3px;">1.0</span>
                        </div>
                    </div>
                </div>

                <!-- ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ -->
                <button id="exportBtn">ğŸ’¾ GLBä¿å­˜</button>
                <button id="exportZipBtn">ğŸ’¾ ZIPä¿å­˜ (iPadOSæ¨å¥¨)</button>

                <!-- ä½¿ã„æ–¹ -->
                <div class="info-box">
                    <p>ğŸ¨ v4 Ultimate - 40ç¨®é¡ã®å½¢Ã—45ç¨®é¡ã®å‹•ã = 1800ä»¥ä¸Šã®çµ„ã¿åˆã‚ã›ï¼</p>
                    <p>palanAR (https://planar.jp/) ã§ARãƒãƒ¼ã‚«ãƒ¼ã‚’ä½œæˆã—ã¦ã¿ã‚“ãªã§å…±æœ‰ã—ã‚ˆã†ï¼</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Import Map for Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let scene, camera, renderer, mesh, mixer, clock;
        let currentAnimation = null;
        let scaleXValue = 1, scaleYValue = 1, scaleZValue = 1;
        let importedModel = null;

        // ãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆæ‹¡å¼µç‰ˆï¼‰
        const presets = [
            { shape: 'sphere', color: '#ff6b6b', animation: 'bounce' },
            { shape: 'cylinder', color: '#4ecdc4', animation: 'rotate' },
            { shape: 'cloud', color: '#ffe66d', animation: 'float' },
            { shape: 'sphere', color: '#a8dadc', animation: 'shake' },
            { shape: 'star', color: '#ffd23f', animation: 'sparkle' },
            { shape: 'box', color: '#ee6c4d', animation: 'pulse' },
            { shape: 'torus', color: '#95e1d3', animation: 'wave' },
            { shape: 'capsule', color: '#f38181', animation: 'stretch' },
            { shape: 'butterfly', color: '#aa96da', animation: 'flutter' },
            { shape: 'arrow', color: '#5dade2', animation: 'slide' },
            { shape: 'octahedron', color: '#f8b500', animation: 'blink' },
            { shape: 'helix', color: '#48c9b0', animation: 'spiral' },
            { shape: 'sphere', color: '#e74c3c', animation: 'tumble' },
            { shape: 'star', color: '#ff5252', animation: 'explode' },
            { shape: 'pyramid', color: '#9575cd', animation: 'wobble' },
            { shape: 'drop', color: '#4fc3f7', animation: 'vibrate' },
            { shape: 'helix', color: '#81c784', animation: 'figure8' },
            { shape: 'heart', color: '#ff80ab', animation: 'dance' },
            { shape: 'butterfly', color: '#ffcc80', animation: 'flap' },
            { shape: 'cylinder', color: '#81c784', animation: 'grow' },
            { shape: 'sphere', color: '#80deea', animation: 'bubble' },
            { shape: 'star', color: '#fff176', animation: 'flash' },
            { shape: 'heart', color: '#ff5252', animation: 'heartbeat' },
            { shape: 'cone', color: '#ce93d8', animation: 'sway' },
            { shape: 'lightning', color: '#ffd700', animation: 'wind' },
            { shape: 'flame', color: '#ff4500', animation: 'fire' },
            { shape: 'wave', color: '#00bfff', animation: 'crowd' },
            { shape: 'lightning', color: '#ffff00', animation: 'electric' },
            { shape: 'leaf', color: '#90ee90', animation: 'expand' },
            { shape: 'sun', color: '#ffa500', animation: 'shrink' }
        ];

        // åˆæœŸåŒ–
        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            clock = new THREE.Clock();

            window.addEventListener('resize', onWindowResize);

            updateMesh();
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            if (mixer) {
                const delta = clock.getDelta();
                mixer.update(delta);
            }

            renderer.render(scene, camera);
        }

        // ã‚«ã‚¹ã‚¿ãƒ ã‚¸ã‚ªãƒ¡ãƒˆãƒªä½œæˆé–¢æ•°ï¼ˆç°¡ç•¥åŒ–ï¼‰
        function createCustomGeometry(type, size) {
            switch (type) {
                case 'star':
                    return createStarGeometry(size);
                case 'heart':
                    return createHeartGeometry(size);
                case 'butterfly':
                    return createButterflyGeometry(size);
                case 'lightning':
                    return createLightningGeometry(size);
                case 'leaf':
                    return createLeafGeometry(size);
                case 'flame':
                    return createFlameGeometry(size);
                case 'wave':
                    return createWaveGeometry(size);
                case 'mountain':
                    return createMountainGeometry(size);
                case 'sun':
                    return createSunGeometry(size);
                case 'moon':
                    return createMoonGeometry(size);
                case 'rocket':
                    return createRocketGeometry(size);
                case 'ufo':
                    return createUFOGeometry(size);
                case 'alien':
                    return createAlienGeometry(size);
                default:
                    return new THREE.SphereGeometry(size, 32, 32);
            }
        }

        // æ˜Ÿå‹
        function createStarGeometry(size) {
            const shape = new THREE.Shape();
            const points = 5;
            const outerRadius = size;
            const innerRadius = size * 0.4;

            for (let i = 0; i < points * 2; i++) {
                const angle = (Math.PI * 2 * i) / (points * 2) - Math.PI / 2;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                if (i === 0) {
                    shape.moveTo(x, y);
                } else {
                    shape.lineTo(x, y);
                }
            }
            shape.closePath();

            return new THREE.ExtrudeGeometry(shape, {
                depth: size * 0.3,
                bevelEnabled: true,
                bevelSegments: 2,
                steps: 2,
                bevelSize: size * 0.05,
                bevelThickness: size * 0.05
            });
        }

        // ãƒãƒ¼ãƒˆå‹
        function createHeartGeometry(size) {
            const shape = new THREE.Shape();
            const x = 0, y = 0;
            
            shape.moveTo(x + size * 0.25, y + size * 0.25);
            shape.bezierCurveTo(x + size * 0.25, y + size * 0.25, x + size * 0.2, y, x, y);
            shape.bezierCurveTo(x - size * 0.3, y, x - size * 0.3, y + size * 0.35, x - size * 0.3, y + size * 0.35);
            shape.bezierCurveTo(x - size * 0.3, y + size * 0.55, x - size * 0.1, y + size * 0.77, x + size * 0.25, y + size * 0.95);
            shape.bezierCurveTo(x + size * 0.6, y + size * 0.77, x + size * 0.8, y + size * 0.55, x + size * 0.8, y + size * 0.35);
            shape.bezierCurveTo(x + size * 0.8, y + size * 0.35, x + size * 0.8, y, x + size * 0.5, y);
            shape.bezierCurveTo(x + size * 0.35, y, x + size * 0.25, y + size * 0.25, x + size * 0.25, y + size * 0.25);
            
            const geometry = new THREE.ExtrudeGeometry(shape, {
                depth: size * 0.4,
                bevelEnabled: true,
                bevelSegments: 2,
                steps: 2,
                bevelSize: size * 0.02,
                bevelThickness: size * 0.02
            });
            
            geometry.center();
            return geometry;
        }

        // è¶ã€…å‹ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        function createButterflyGeometry(size) {
            const shape = new THREE.Shape();
            
            // å³ç¾½
            shape.moveTo(0, 0);
            shape.quadraticCurveTo(size * 0.8, size * 0.3, size * 0.8, 0);
            shape.quadraticCurveTo(size * 0.8, -size * 0.3, size * 0.4, -size * 0.4);
            shape.quadraticCurveTo(size * 0.2, -size * 0.2, 0, 0);
            
            // å·¦ç¾½ï¼ˆå¯¾ç§°ï¼‰
            shape.quadraticCurveTo(-size * 0.2, -size * 0.2, -size * 0.4, -size * 0.4);
            shape.quadraticCurveTo(-size * 0.8, -size * 0.3, -size * 0.8, 0);
            shape.quadraticCurveTo(-size * 0.8, size * 0.3, 0, 0);
            
            const geometry = new THREE.ExtrudeGeometry(shape, {
                depth: size * 0.1,
                bevelEnabled: false
            });
            
            geometry.center();
            return geometry;
        }

        // ç¨²å¦»å‹
        function createLightningGeometry(size) {
            const shape = new THREE.Shape();
            
            shape.moveTo(0, size);
            shape.lineTo(-size * 0.2, size * 0.3);
            shape.lineTo(size * 0.1, size * 0.3);
            shape.lineTo(-size * 0.1, -size * 0.3);
            shape.lineTo(size * 0.2, -size * 0.3);
            shape.lineTo(0, -size);
            shape.lineTo(size * 0.1, -size * 0.2);
            shape.lineTo(-size * 0.05, -size * 0.2);
            shape.lineTo(size * 0.05, size * 0.2);
            shape.lineTo(-size * 0.1, size * 0.2);
            shape.closePath();
            
            return new THREE.ExtrudeGeometry(shape, {
                depth: size * 0.2,
                bevelEnabled: false
            });
        }

        // è‘‰ã£ã±å‹
        function createLeafGeometry(size) {
            const shape = new THREE.Shape();
            
            shape.moveTo(0, -size);
            shape.quadraticCurveTo(size * 0.4, -size * 0.6, size * 0.4, 0);
            shape.quadraticCurveTo(size * 0.4, size * 0.6, 0, size);
            shape.quadraticCurveTo(-size * 0.4, size * 0.6, -size * 0.4, 0);
            shape.quadraticCurveTo(-size * 0.4, -size * 0.6, 0, -size);
            
            const geometry = new THREE.ExtrudeGeometry(shape, {
                depth: size * 0.1,
                bevelEnabled: true,
                bevelSize: size * 0.02,
                bevelThickness: size * 0.02
            });
            
            geometry.center();
            return geometry;
        }

        // ç‚å‹
        function createFlameGeometry(size) {
            const shape = new THREE.Shape();
            
            shape.moveTo(0, size);
            shape.quadraticCurveTo(size * 0.3, size * 0.5, size * 0.2, 0);
            shape.quadraticCurveTo(size * 0.1, -size * 0.8, 0, -size);
            shape.quadraticCurveTo(-size * 0.1, -size * 0.8, -size * 0.2, 0);
            shape.quadraticCurveTo(-size * 0.3, size * 0.5, 0, size);
            
            return new THREE.ExtrudeGeometry(shape, {
                depth: size * 0.3,
                bevelEnabled: false
            });
        }

        // æ³¢å‹
        function createWaveGeometry(size) {
            const geometry = new THREE.PlaneGeometry(size * 2, size, 32, 32);
            const positions = geometry.attributes.position.array;
            
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                positions[i + 2] = Math.sin(x * 2) * size * 0.2;
            }
            
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
            return geometry;
        }

        // å±±å‹
        function createMountainGeometry(size) {
            return new THREE.ConeGeometry(size, size * 1.5, 4);
        }

        // å¤ªé™½å‹ï¼ˆå…‰ç·šä»˜ãï¼‰
        function createSunGeometry(size) {
            const group = new THREE.Group();
            const shape = new THREE.Shape();
            const rays = 12;
            const innerRadius = size * 0.5;
            const outerRadius = size;
            
            for (let i = 0; i < rays; i++) {
                const angle = (Math.PI * 2 * i) / rays;
                const angle2 = (Math.PI * 2 * (i + 0.5)) / rays;
                
                if (i === 0) {
                    shape.moveTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
                } else {
                    shape.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
                }
                shape.lineTo(Math.cos(angle2) * innerRadius, Math.sin(angle2) * innerRadius);
            }
            shape.closePath();
            
            return new THREE.ExtrudeGeometry(shape, {
                depth: size * 0.2,
                bevelEnabled: true,
                bevelSize: size * 0.02,
                bevelThickness: size * 0.02
            });
        }

        // ä¸‰æ—¥æœˆå‹ï¼ˆãã‚Œã„ãªã‚«ãƒ¼ãƒ–ï¼‰
        function createMoonGeometry(size) {
            const shape = new THREE.Shape();
            const radius = size;
            
            // å¤–å´ã®å††å¼§
            shape.moveTo(0, -radius);
            shape.absarc(0, 0, radius, -Math.PI / 2, Math.PI / 2, false);
            
            // å†…å´ã®å††å¼§ï¼ˆå°‘ã—ãšã‚‰ã—ã¦ä¸‰æ—¥æœˆã‚’ä½œã‚‹ï¼‰
            shape.absarc(radius * 0.3, 0, radius * 0.8, Math.PI / 2, -Math.PI / 2, true);
            shape.closePath();
            
            return new THREE.ExtrudeGeometry(shape, {
                depth: size * 0.15,
                bevelEnabled: true,
                bevelSize: size * 0.02,
                bevelThickness: size * 0.02
            });
        }

        // ãƒ­ã‚±ãƒƒãƒˆå‹
        function createRocketGeometry(size) {
            const shape = new THREE.Shape();
            const width = size * 0.3;
            const height = size * 1.5;
            
            // ãƒ­ã‚±ãƒƒãƒˆã®æœ¬ä½“
            shape.moveTo(-width/2, -height/2);
            shape.lineTo(-width/2, height * 0.3);
            
            // å…ˆç«¯ï¼ˆå††éŒéƒ¨åˆ†ï¼‰
            shape.lineTo(-width * 0.8, height * 0.3);
            shape.lineTo(0, height/2);
            shape.lineTo(width * 0.8, height * 0.3);
            shape.lineTo(width/2, height * 0.3);
            
            // æœ¬ä½“ã®å³å´
            shape.lineTo(width/2, -height/2);
            
            // å™´å°„å£
            shape.lineTo(width * 0.3, -height/2);
            shape.lineTo(width * 0.2, -height * 0.6);
            shape.lineTo(0, -height * 0.55);
            shape.lineTo(-width * 0.2, -height * 0.6);
            shape.lineTo(-width * 0.3, -height/2);
            shape.closePath();
            
            const geometry = new THREE.ExtrudeGeometry(shape, {
                depth: size * 0.3,
                bevelEnabled: true,
                bevelSize: size * 0.02,
                bevelThickness: size * 0.02
            });
            
            geometry.center();
            return geometry;
        }

        // UFOå‹
        function createUFOGeometry(size) {
            // å††ç›¤å‹ã®UFO
            const geometry = new THREE.CylinderGeometry(
                size * 0.3,  // ä¸Šéƒ¨ã®åŠå¾„ï¼ˆãƒ‰ãƒ¼ãƒ ï¼‰
                size * 0.9,  // ä¸‹éƒ¨ã®åŠå¾„ï¼ˆå††ç›¤ï¼‰
                size * 0.3,  // é«˜ã•
                32,          // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°
                1,           // é«˜ã•ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
                false        // ã‚ªãƒ¼ãƒ—ãƒ³ã‚¨ãƒ³ãƒ‰
            );
            
            // ãƒ‰ãƒ¼ãƒ ã‚’è¿½åŠ ï¼ˆä¸Šéƒ¨ã®åŠçƒï¼‰
            const dome = new THREE.SphereGeometry(size * 0.3, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const mergedGeometry = new THREE.BufferGeometry();
            
            // ç°¡å˜ã®ãŸã‚ã€å††æŸ±ã‚’ãã®ã¾ã¾è¿”ã™ï¼ˆæœ¬æ¥ã¯åˆæˆã™ã¹ãï¼‰
            return geometry;
        }

        // å®‡å®™äººå‹ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªã‚°ãƒ¬ã‚¤ã‚¿ã‚¤ãƒ—ï¼‰
        function createAlienGeometry(size) {
            const shape = new THREE.Shape();
            
            // é ­éƒ¨ï¼ˆå¤§ããªæ¥•å††ï¼‰
            const headRadius = size * 0.5;
            const bodyWidth = size * 0.3;
            const bodyHeight = size * 0.8;
            
            // é ­
            shape.moveTo(0, size * 0.5);
            shape.quadraticCurveTo(headRadius, size * 0.5, headRadius, 0);
            shape.quadraticCurveTo(headRadius, -size * 0.2, bodyWidth, -size * 0.2);
            
            // ä½“
            shape.lineTo(bodyWidth, -bodyHeight);
            shape.lineTo(bodyWidth * 0.7, -bodyHeight);
            shape.lineTo(bodyWidth * 0.5, -bodyHeight * 0.6);
            shape.lineTo(0, -bodyHeight * 0.6);
            shape.lineTo(-bodyWidth * 0.5, -bodyHeight * 0.6);
            shape.lineTo(-bodyWidth * 0.7, -bodyHeight);
            shape.lineTo(-bodyWidth, -bodyHeight);
            shape.lineTo(-bodyWidth, -size * 0.2);
            
            // é ­ã®å·¦å´
            shape.quadraticCurveTo(-headRadius, -size * 0.2, -headRadius, 0);
            shape.quadraticCurveTo(-headRadius, size * 0.5, 0, size * 0.5);
            
            const geometry = new THREE.ExtrudeGeometry(shape, {
                depth: size * 0.2,
                bevelEnabled: true,
                bevelSize: size * 0.02,
                bevelThickness: size * 0.02
            });
            
            geometry.center();
            return geometry;
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function updateMesh() {
            if (mesh) {
                scene.remove(mesh);
                // é€šå¸¸ã®å½¢çŠ¶ã®å ´åˆã®ã¿disposeï¼ˆã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ã¯disposeã—ãªã„ï¼‰
                if (!importedModel && mesh.geometry && mesh.material) {
                    mesh.geometry.dispose();
                    if (Array.isArray(mesh.material)) {
                        mesh.material.forEach(mat => mat.dispose());
                    } else {
                        mesh.material.dispose();
                    }
                }
            }

            const shape = document.getElementById('shape').value;
            const color = document.getElementById('color').value;
            const size = parseFloat(document.getElementById('size').value);

            let geometry;
            
            // åŸºæœ¬å½¢çŠ¶
            const basicShapes = {
                'sphere': () => new THREE.SphereGeometry(size, 32, 32),
                'box': () => new THREE.BoxGeometry(size, size, size),
                'cuboid': () => new THREE.BoxGeometry(size, size, size),
                'cylinder': () => new THREE.CylinderGeometry(size * 0.5, size * 0.5, size * 1.5, 32),
                'cone': () => new THREE.ConeGeometry(size * 0.7, size * 1.5, 32),
                'octahedron': () => new THREE.OctahedronGeometry(size),
                'torus': () => new THREE.TorusGeometry(size * 0.7, size * 0.3, 16, 100),
                'plane': () => new THREE.BoxGeometry(size * 1.5, size * 0.1, size * 1.5),
                'ring': () => new THREE.TorusGeometry(size * 0.8, size * 0.1, 16, 100),
                'pyramid': () => new THREE.ConeGeometry(size * 0.8, size * 1.2, 4),
                'diamond': () => { const g = new THREE.OctahedronGeometry(size * 0.8); g.scale(1, 1.5, 1); return g; },
                'crystal': () => { const g = new THREE.OctahedronGeometry(size); g.scale(0.8, 2, 0.8); return g; },
                'cross': () => new THREE.BoxGeometry(size * 1.5, size * 0.3, size * 0.3),
                'arrow': () => new THREE.ConeGeometry(size * 0.5, size * 1.2, 3),
                'gear': () => new THREE.CylinderGeometry(size * 0.8, size * 0.8, size * 0.3, 8),
                'drop': () => { const g = new THREE.SphereGeometry(size * 0.7, 32, 32); g.scale(1, 1.5, 1); return g; },
                'cloud': () => { const g = new THREE.SphereGeometry(size * 0.8, 32, 16); g.scale(1.5, 0.8, 1); return g; },
                'flower': () => new THREE.DodecahedronGeometry(size * 0.8),
                'crescent': () => new THREE.TorusGeometry(size * 0.8, size * 0.3, 16, 32, Math.PI * 1.5),
                'snowflake': () => new THREE.OctahedronGeometry(size * 0.9),
                'egg': () => { const g = new THREE.SphereGeometry(size * 0.8, 32, 32); g.scale(1, 1.3, 1); return g; },
                'tetrahedron': () => new THREE.TetrahedronGeometry(size),
                'icosahedron': () => new THREE.IcosahedronGeometry(size * 0.9),
                'knot': () => new THREE.TorusKnotGeometry(size * 0.6, size * 0.2, 100, 16),
                'helix': () => new THREE.TorusKnotGeometry(size * 0.5, size * 0.15, 100, 8),
                'hexagon': () => new THREE.CylinderGeometry(size * 0.8, size * 0.8, size * 1.2, 6),
                'pentaprism': () => new THREE.CylinderGeometry(size * 0.8, size * 0.8, size * 1.2, 5),
                'capsule': () => new THREE.CapsuleGeometry(size * 0.3, size * 0.6, 4, 8),
                'prism': () => new THREE.CylinderGeometry(size * 0.6, size * 0.6, size * 1.2, 3)
            };

            // å½¢çŠ¶ã®ä½œæˆ
            if (basicShapes[shape]) {
                geometry = basicShapes[shape]();
            } else {
                geometry = createCustomGeometry(shape, size);
            }

            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.5,
                metalness: 0.2,
            });

            // ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
            if (importedModel) {
                // ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ã‚’æ·±ãã‚¯ãƒ­ãƒ¼ãƒ³ï¼ˆã™ã¹ã¦ã®å­ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å«ã‚€ï¼‰
                mesh = importedModel.clone(true);
                mesh.name = 'mesh';
                
                // è‰²å¤‰æ›´ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®å€¤ã‚’ç¢ºèª
                const applyColor = document.getElementById('applyColorToImported').checked;
                if (applyColor) {
                    mesh.traverse((child) => {
                        if (child.isMesh) {
                            child.material = material.clone();
                        }
                    });
                }
            } else {
                mesh = new THREE.Mesh(geometry, material);
                mesh.name = 'mesh';
            }
            
            // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨
            scaleXValue = parseFloat(document.getElementById('scaleX').value);
            scaleYValue = parseFloat(document.getElementById('scaleY').value);
            scaleZValue = parseFloat(document.getElementById('scaleZ').value);
            mesh.scale.set(scaleXValue, scaleYValue, scaleZValue);
            
            // ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ
            mesh.position.set(0, 0, 0);
            mesh.rotation.set(0, 0, 0);
            
            scene.add(mesh);
            
            console.log('Mesh updated:', {
                isImported: !!importedModel,
                meshName: mesh.name,
                scale: { x: scaleXValue, y: scaleYValue, z: scaleZValue },
                childrenCount: mesh.children ? mesh.children.length : 0,
                visible: mesh.visible
            });

            updateAnimation();
        }

        function createAnimationClip(animType, duration) {
            const tracks = [];
            const times = [0, duration * 0.25, duration * 0.5, duration * 0.75, duration];
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®šç¾©ï¼ˆç°¡ç•¥åŒ–ï¼‰
            const animations = {
                'bounce': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        [0, duration * 0.5, duration],
                        [0, 0, 0, 0, 2, 0, 0, 0, 0]
                    ));
                },
                'rotate': () => {
                    const rotValues = [];
                    for (let i = 0; i <= 4; i++) {
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), (i / 4) * Math.PI * 2);
                        rotValues.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotValues));
                },
                'float': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        [0, duration * 0.5, duration],
                        [0, -0.5, 0, 0, 0.5, 0, 0, -0.5, 0]
                    ));
                },
                'shake': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        times,
                        [0, 0, 0, 0.2, 0, 0, -0.2, 0, 0, 0.2, 0, 0, 0, 0, 0]
                    ));
                },
                'pulse': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration * 0.5, duration],
                        [1, 1, 1, 1.5, 1.5, 1.5, 1, 1, 1]
                    ));
                },
                'sparkle': () => {
                    const rotValues = [];
                    const scaleValues = [];
                    for (let i = 0; i <= 2; i++) {
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 0, 1), (i / 2) * Math.PI);
                        rotValues.push(q.x, q.y, q.z, q.w);
                        const scale = i === 1 ? 1.3 : 1.0;
                        scaleValues.push(scale, scale, scale);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', [0, duration * 0.5, duration], rotValues));
                    tracks.push(new THREE.VectorKeyframeTrack('.scale', [0, duration * 0.5, duration], scaleValues));
                },
                // æ–°ã—ã„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                'electric': () => {
                    const positions = [];
                    for (let i = 0; i <= 10; i++) {
                        const offset = Math.random() * 0.2 - 0.1;
                        positions.push(offset, offset * 0.5, offset * 0.3);
                    }
                    const electricTimes = [];
                    for (let i = 0; i <= 10; i++) {
                        electricTimes.push((i / 10) * duration);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', electricTimes, positions));
                },
                'fire': () => {
                    const positions = [];
                    const scales = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const wobble = Math.sin(t * Math.PI * 4) * 0.1;
                        positions.push(wobble, t * 0.5, 0);
                        const scale = 1 + Math.sin(t * Math.PI * 2) * 0.2;
                        scales.push(scale, scale * 1.2, scale);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', times, positions));
                    tracks.push(new THREE.VectorKeyframeTrack('.scale', times, scales));
                },
                'snake': () => {
                    const positions = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const x = Math.sin(t * Math.PI * 4) * 0.5;
                        const z = Math.cos(t * Math.PI * 2) * 0.3;
                        positions.push(x, 0, z);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', times, positions));
                },
                'swim': () => {
                    const positions = [];
                    const rotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const x = Math.sin(t * Math.PI * 2) * 0.8;
                        const y = Math.sin(t * Math.PI * 4) * 0.2;
                        positions.push(x, y, 0);
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.sin(t * Math.PI * 2) * 0.2);
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', times, positions));
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotations));
                },
                'wind': () => {
                    const positions = [];
                    const rotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const x = t * 2 - 1;
                        const y = Math.sin(t * Math.PI * 2) * 0.3;
                        positions.push(x, y, 0);
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), t * Math.PI * 0.5);
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', times, positions));
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotations));
                },
                'crowd': () => {
                    const positions = [];
                    for (let i = 0; i <= 10; i++) {
                        const offsetX = (Math.random() - 0.5) * 0.1;
                        const offsetY = (Math.random() - 0.5) * 0.1;
                        positions.push(offsetX, offsetY, 0);
                    }
                    const crowdTimes = [];
                    for (let i = 0; i <= 10; i++) {
                        crowdTimes.push((i / 10) * duration);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', crowdTimes, positions));
                },
                'warm': () => {
                    const scales = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const scale = 1 + Math.sin(t * Math.PI * 2) * 0.05;
                        scales.push(scale, scale, scale);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.scale', times, scales));
                },
                'shrink': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration],
                        [1, 1, 1, 0.3, 0.3, 0.3]
                    ));
                },
                'morph': () => {
                    const scales = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const scaleX = 1 + Math.sin(t * Math.PI * 2) * 0.3;
                        const scaleY = 1 - Math.sin(t * Math.PI * 2) * 0.2;
                        const scaleZ = 1 + Math.cos(t * Math.PI * 2) * 0.25;
                        scales.push(scaleX, scaleY, scaleZ);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.scale', times, scales));
                },
                'expand': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration],
                        [0.5, 0.5, 0.5, 1.5, 1.5, 1.5]
                    ));
                }
            };

            // æ—¢å­˜ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚‚å«ã‚ã‚‹
            const existingAnimations = {
                'wave': () => {
                    const positions = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const x = Math.sin(t * Math.PI * 2) * 0.5;
                        const y = Math.cos(t * Math.PI * 2) * 0.3;
                        positions.push(x, y, 0);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', times, positions));
                },
                'spiral': () => {
                    const positions = [];
                    const rotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const angle = t * Math.PI * 2;
                        positions.push(Math.cos(angle), t * 2, Math.sin(angle));
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', times, positions));
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotations));
                },
                'stretch': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration * 0.5, duration],
                        [1, 1, 1, 1, 2, 1, 1, 1, 1]
                    ));
                },
                'blink': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        times,
                        [1, 1, 1, 0.1, 0.1, 0.1, 1, 1, 1, 0.1, 0.1, 0.1, 1, 1, 1]
                    ));
                },
                'swing': () => {
                    const rotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const angle = Math.sin((i / 4) * Math.PI * 2) * 0.5;
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 0, 1), angle);
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotations));
                },
                'slide': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        [0, duration],
                        [-2, 0, 0, 2, 0, 0]
                    ));
                },
                'zigzag': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        times,
                        [0, 0, 0, 1, 0.5, 0, -1, 1, 0, 1, 1.5, 0, 0, 2, 0]
                    ));
                },
                'figure8': () => {
                    const positions = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = (i / 4) * Math.PI * 2;
                        positions.push(Math.sin(t) * 1.5, Math.sin(t * 2) * 0.7, 0);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', times, positions));
                },
                'circle': () => {
                    const positions = [];
                    for (let i = 0; i <= 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        positions.push(Math.cos(angle) * 1.5, 0, Math.sin(angle) * 1.5);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', times, positions));
                },
                'orbit': () => {
                    const positions = [];
                    const rotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        positions.push(Math.cos(angle) * 2, 0, Math.sin(angle) * 1.5);
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', times, positions));
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotations));
                },
                'tornado': () => {
                    const positions = [];
                    const rotations = [];
                    for (let i = 0; i <= 8; i++) {
                        const t = i / 8;
                        const angle = t * Math.PI * 4;
                        const radius = t * 1.5;
                        positions.push(Math.cos(angle) * radius, t * 3, Math.sin(angle) * radius);
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle * 2);
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    const tornadoTimes = [];
                    for (let i = 0; i <= 8; i++) {
                        tornadoTimes.push((i / 8) * duration);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', tornadoTimes, positions));
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', tornadoTimes, rotations));
                },
                'pendulum': () => {
                    const rotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const angle = Math.sin((i / 4) * Math.PI) * 0.7;
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 0, 1), angle);
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotations));
                },
                'spin_bounce': () => {
                    const positions = [0, 0, 0, 0, 2, 0, 0, 0, 0];
                    const rotations = [];
                    for (let i = 0; i <= 2; i++) {
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), (i / 2) * Math.PI * 2);
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', [0, duration * 0.5, duration], positions));
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', [0, duration * 0.5, duration], rotations));
                },
                'twist': () => {
                    const rotations = [];
                    const scales = [];
                    for (let i = 0; i <= 2; i++) {
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), (i / 2) * Math.PI);
                        rotations.push(q.x, q.y, q.z, q.w);
                        const scale = i === 1 ? 1.2 : 1.0;
                        scales.push(scale, 1.0, scale);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', [0, duration * 0.5, duration], rotations));
                    tracks.push(new THREE.VectorKeyframeTrack('.scale', [0, duration * 0.5, duration], scales));
                },
                'wobble': () => {
                    const rotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const q = new THREE.Quaternion();
                        q.setFromEuler(new THREE.Euler(
                            Math.sin(t * Math.PI * 2) * 0.3,
                            0,
                            Math.cos(t * Math.PI * 2) * 0.3
                        ));
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotations));
                },
                'jello': () => {
                    const scales = [];
                    for (let i = 0; i <= 8; i++) {
                        const t = i / 8;
                        const scaleX = 1 + Math.sin(t * Math.PI * 4) * 0.2;
                        const scaleY = 1 - Math.sin(t * Math.PI * 4) * 0.1;
                        const scaleZ = 1 + Math.cos(t * Math.PI * 4) * 0.15;
                        scales.push(scaleX, scaleY, scaleZ);
                    }
                    const jelloTimes = [];
                    for (let i = 0; i <= 8; i++) {
                        jelloTimes.push((i / 8) * duration);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.scale', jelloTimes, scales));
                },
                'grow': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration],
                        [0.1, 0.1, 0.1, 1, 1, 1]
                    ));
                },
                'flap': () => {
                    const rotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const angle = Math.sin((i / 4) * Math.PI * 4) * 0.5;
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(1, 0, 0), angle);
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotations));
                },
                'flutter': () => {
                    const positions = [];
                    const rotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        positions.push(
                            Math.sin(t * Math.PI * 2) * 0.3,
                            Math.sin(t * Math.PI * 4) * 0.5,
                            0
                        );
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.sin(t * Math.PI * 2) * 0.3);
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', times, positions));
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotations));
                },
                'tumble': () => {
                    const rotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        const q = new THREE.Quaternion();
                        q.setFromEuler(new THREE.Euler(
                            t * Math.PI * 2,
                            t * Math.PI * 2 * 0.7,
                            0
                        ));
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotations));
                },
                'dance': () => {
                    const positions = [];
                    const rotations = [];
                    const scales = [];
                    for (let i = 0; i <= 5; i++) {
                        const t = i / 5;
                        positions.push(
                            Math.sin(t * Math.PI * 2) * 0.5,
                            Math.abs(Math.sin(t * Math.PI * 4)) * 0.8,
                            0
                        );
                        const q = new THREE.Quaternion();
                        q.setFromEuler(new THREE.Euler(
                            Math.sin(t * Math.PI * 2) * 0.3,
                            Math.sin(t * Math.PI * 2) * 0.15,
                            Math.sin(t * Math.PI * 2) * 0.09
                        ));
                        rotations.push(q.x, q.y, q.z, q.w);
                        const scale = 1 + Math.sin(t * Math.PI * 4) * 0.1;
                        scales.push(scale, scale, scale);
                    }
                    const danceTimes = [0, duration * 0.2, duration * 0.4, duration * 0.6, duration * 0.8, duration];
                    tracks.push(new THREE.VectorKeyframeTrack('.position', danceTimes, positions));
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', danceTimes, rotations));
                    tracks.push(new THREE.VectorKeyframeTrack('.scale', danceTimes, scales));
                },
                'heartbeat': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration * 0.1, duration * 0.2, duration * 0.3, duration * 0.4, duration * 0.9, duration],
                        [1, 1, 1, 1.3, 1.3, 1.3, 1, 1, 1, 1.3, 1.3, 1.3, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ));
                },
                'sway': () => {
                    const rotations = [];
                    for (let i = 0; i <= 4; i++) {
                        const angle = Math.sin((i / 4) * Math.PI * 2) * 0.4;
                        const q = new THREE.Quaternion();
                        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                        rotations.push(q.x, q.y, q.z, q.w);
                    }
                    tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotations));
                },
                'vibrate': () => {
                    const positions = [];
                    for (let i = 0; i <= 10; i++) {
                        const offset = (i % 2 === 0) ? 0.1 : -0.1;
                        positions.push(offset, offset * 0.5, 0);
                    }
                    const vibrateTimes = [];
                    for (let i = 0; i <= 10; i++) {
                        vibrateTimes.push((i / 10) * duration);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', vibrateTimes, positions));
                },
                'bubble': () => {
                    const positions = [];
                    const scales = [];
                    for (let i = 0; i <= 4; i++) {
                        const t = i / 4;
                        positions.push(Math.sin(t * Math.PI * 4) * 0.2, t * 2, 0);
                        const scale = 1 + Math.sin(t * Math.PI * 2) * 0.2;
                        scales.push(scale, scale, scale);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.position', times, positions));
                    tracks.push(new THREE.VectorKeyframeTrack('.scale', times, scales));
                },
                'flash': () => {
                    const scales = [];
                    for (let i = 0; i <= 8; i++) {
                        const scale = (i % 2 === 0) ? 1.5 : 0.5;
                        scales.push(scale, scale, scale);
                    }
                    const flashTimes = [];
                    for (let i = 0; i <= 8; i++) {
                        flashTimes.push((i / 8) * duration);
                    }
                    tracks.push(new THREE.VectorKeyframeTrack('.scale', flashTimes, scales));
                },
                'explode': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration * 0.7, duration],
                        [0.1, 0.1, 0.1, 2, 2, 2, 1.5, 1.5, 1.5]
                    ));
                },
                'implode': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration * 0.7, duration],
                        [2, 2, 2, 0.1, 0.1, 0.1, 1, 1, 1]
                    ));
                },
                'teleport': () => {
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.position',
                        [0, duration * 0.4, duration * 0.45, duration * 0.5, duration * 0.55, duration],
                        [-2, 0, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0]
                    ));
                    tracks.push(new THREE.VectorKeyframeTrack(
                        '.scale',
                        [0, duration * 0.4, duration * 0.5, duration * 0.6, duration],
                        [1, 1, 1, 1, 1, 1, 0.01, 0.01, 0.01, 1, 1, 1, 1, 1, 1]
                    ));
                }
            };

            // ã™ã¹ã¦ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’çµåˆ
            const allAnimations = { ...animations, ...existingAnimations };
            
            if (allAnimations[animType]) {
                allAnimations[animType]();
            } else {
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆå›è»¢ï¼‰
                const rotValues = [];
                for (let i = 0; i <= 4; i++) {
                    const q = new THREE.Quaternion();
                    q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), (i / 4) * Math.PI * 2);
                    rotValues.push(q.x, q.y, q.z, q.w);
                }
                tracks.push(new THREE.QuaternionKeyframeTrack('.quaternion', times, rotValues));
            }
            
            return new THREE.AnimationClip('animation', duration, tracks);
        }

        function updateAnimation() {
            if (!mesh) {
                console.warn('updateAnimation: mesh is null');
                return;
            }

            console.log('updateAnimation called:', {
                meshExists: !!mesh,
                meshVisible: mesh.visible,
                meshInScene: scene.children.includes(mesh)
            });

            const animType = document.getElementById('animation').value;
            const speed = parseFloat(document.getElementById('speed').value);
            const duration = 2 / speed;

            currentAnimation = createAnimationClip(animType, duration);
            
            if (mixer) {
                mixer.stopAllAction();
                mixer.uncacheRoot(mesh);
            }
            
            mixer = new THREE.AnimationMixer(mesh);
            const action = mixer.clipAction(currentAnimation);
            action.loop = THREE.LoopRepeat;
            action.play();
        }

        async function exportGLB(formatType = 'glb') {
            if (!mesh) {
                alert('3Dãƒ¢ãƒ‡ãƒ«ãŒæº–å‚™ã§ãã¦ã„ã¾ã›ã‚“ã€‚');
                return;
            }

            const isBinary = formatType === 'glb';
            const exportBtn = isBinary 
                ? document.getElementById('exportBtn')
                : document.getElementById('exportZipBtn');
            
            exportBtn.disabled = true;
            exportBtn.textContent = 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­...';

            try {
                // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆç”¨ã®ã‚·ãƒ¼ãƒ³ã‚’ä½œæˆ
                const exportScene = new THREE.Scene();
                
                // ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒ­ãƒ¼ãƒ³
                let exportMesh;
                if (importedModel) {
                    // ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ã®å ´åˆã¯å®Œå…¨ã«ã‚¯ãƒ­ãƒ¼ãƒ³ï¼ˆæ·±ã„ã‚¯ãƒ­ãƒ¼ãƒ³ï¼‰
                    exportMesh = mesh.clone(true);
                } else {
                    // é€šå¸¸ã®å½¢çŠ¶ã®å ´åˆ
                    exportMesh = new THREE.Mesh(
                        mesh.geometry.clone(),
                        mesh.material.clone()
                    );
                }
                
                // é‡è¦: ãƒ¡ãƒƒã‚·ãƒ¥åã‚’è¨­å®šï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ä¸€è‡´ã•ã›ã‚‹ï¼‰
                exportMesh.name = 'mesh';
                exportMesh.position.set(0, 0, 0);
                exportMesh.rotation.set(0, 0, 0);
                exportMesh.scale.set(scaleXValue, scaleYValue, scaleZValue);
                exportMesh.updateMatrix();
                exportMesh.updateMatrixWorld(true);
                
                exportScene.add(exportMesh);

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
                let animations = [];
                if (currentAnimation && currentAnimation.tracks.length > 0) {
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒªãƒƒãƒ—ã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦èª¿æ•´
                    const exportClip = currentAnimation.clone();
                    exportClip.name = 'animation';
                    
                    // ãƒˆãƒ©ãƒƒã‚¯ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ‘ã‚¹ã‚’ç¢ºèªãƒ»ä¿®æ­£
                    exportClip.tracks = exportClip.tracks.map(track => {
                        const newTrack = track.clone();
                        // .position -> mesh.position ã®ã‚ˆã†ãªå½¢å¼ã«çµ±ä¸€
                        if (!newTrack.name.includes('mesh')) {
                            newTrack.name = 'mesh' + newTrack.name;
                        }
                        return newTrack;
                    });
                    
                    animations = [exportClip];
                    
                    console.log('Animation prepared:', {
                        name: exportClip.name,
                        duration: exportClip.duration,
                        trackCount: exportClip.tracks.length,
                        tracks: exportClip.tracks.map(t => ({ name: t.name, type: t.constructor.name }))
                    });
                }

                // GLTFExporterè¨­å®šï¼ˆpalanARäº’æ›æ€§ã‚’é‡è¦–ï¼‰
                const exportOptions = {
                    binary: isBinary,
                    animations: animations,
                    forceIndices: true,
                    forcePowerOfTwoTextures: false,
                    truncateDrawRange: false,
                    includeCustomExtensions: false,
                    maxTextureSize: 4096,
                    embedImages: true
                };

                console.log('Export options:', exportOptions);
                console.log('Mesh to export:', exportMesh);

                const exporter = new GLTFExporter();
                
                // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Ÿè¡Œ
                exporter.parse(
                    exportScene,
                    async function (result) {
                        try {
                            let blob;
                            let finalFileName;
                            let finalMimeType;
                            const timestamp = new Date().toISOString()
                                .replace(/[:.]/g, '-')
                                .slice(0, 19);
                            
                            if (isBinary) {
                                // GLB: ãƒã‚¤ãƒŠãƒªå½¢å¼
                                const isArrayBuffer = result instanceof ArrayBuffer;
                                blob = isArrayBuffer 
                                    ? new Blob([result], { type: 'model/gltf-binary' })
                                    : result;
                                finalFileName = `sensory-poetry-${timestamp}.glb`;
                                finalMimeType = 'model/gltf-binary';
                            } else {
                                // GLTF: JSONå½¢å¼ â†’ ZIPåœ§ç¸®
                                const output = JSON.stringify(result, null, 2);
                                const gltfFileName = `sensory-poetry-${timestamp}.gltf`;
                                
                                if (typeof JSZip !== 'undefined') {
                                    const zip = new JSZip();
                                    zip.file(gltfFileName, output);
                                    
                                    blob = await zip.generateAsync({ 
                                        type: 'blob',
                                        compression: 'DEFLATE',
                                        compressionOptions: { level: 9 }
                                    });
                                    
                                    finalFileName = `sensory-poetry-${timestamp}.zip`;
                                    finalMimeType = 'application/zip';
                                    console.log('GLTF compressed to ZIP');
                                } else {
                                    blob = new Blob([output], { type: 'model/gltf+json' });
                                    finalFileName = gltfFileName;
                                    finalMimeType = 'model/gltf+json';
                                    console.warn('JSZip not available');
                                }
                            }
                            
                            const byteLength = blob.size;
                            console.log('Export successful:', {
                                format: isBinary ? 'GLB' : 'GLTF-ZIP',
                                size: byteLength,
                                sizeKB: Math.round(byteLength / 1024)
                            });
                            
                            // ãƒ‡ãƒã‚¤ã‚¹åˆ¤å®š
                            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                            
                            // iOS Share API
                            if (isIOS && navigator.share) {
                                try {
                                    const file = new File([blob], finalFileName, { 
                                        type: finalMimeType,
                                        lastModified: Date.now()
                                    });
                                    
                                    if (navigator.canShare && navigator.canShare({ files: [file] })) {
                                        await navigator.share({
                                            files: [file],
                                            title: `æ„Ÿè¦šã®è©© (${isBinary ? 'GLB' : 'GLTF-ZIP'})`,
                                            text: animations.length > 0 ? 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ã3Dãƒ¢ãƒ‡ãƒ«' : '3Dãƒ¢ãƒ‡ãƒ«'
                                        });
                                        
                                        exportBtn.disabled = false;
                                        exportBtn.textContent = isBinary ? 'ğŸ’¾ GLBä¿å­˜' : 'ğŸ’¾ ZIPä¿å­˜ (iPadOSæ¨å¥¨)';
                                        
                                        alert(`âœ… å…±æœ‰ã—ã¾ã—ãŸï¼ˆ${isBinary ? 'GLB' : 'GLTF-ZIP'}å½¢å¼ï¼‰\n\nãƒ•ã‚¡ã‚¤ãƒ«å: ${finalFileName}\nã‚µã‚¤ã‚º: ${Math.round(byteLength / 1024)}KB\nã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³: ${animations.length > 0 ? 'ã‚ã‚Š' : 'ãªã—'}\n\nã€palanARã§ä½¿ç”¨ã€‘\n1. https://planar.jp/ ã«ã‚¢ã‚¯ã‚»ã‚¹\n2. ã€ŒARãƒãƒ¼ã‚«ãƒ¼ä½œæˆã€ã‹ã‚‰ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰\n3. ${isBinary ? '' : 'ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãã®ã¾ã¾ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰'}`);
                                        return;
                                    }
                                } catch (error) {
                                    if (error.name !== 'AbortError') {
                                        console.log('Share error:', error);
                                    }
                                }
                            }
                            
                            // æ¨™æº–ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = finalFileName;
                            link.style.display = 'none';
                            
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            
                            setTimeout(() => URL.revokeObjectURL(url), 1000);
                            
                            exportBtn.disabled = false;
                            exportBtn.textContent = isBinary ? 'ğŸ’¾ GLBä¿å­˜' : 'ğŸ’¾ ZIPä¿å­˜ (iPadOSæ¨å¥¨)';
                            
                            const formatInfo = isBinary ? 'GLBå½¢å¼' : 'GLTF-ZIPå½¢å¼ï¼ˆpalanARå¯¾å¿œï¼‰';
                            alert(`âœ… ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†\n\nå½¢å¼: ${formatInfo}\nãƒ•ã‚¡ã‚¤ãƒ«å: ${finalFileName}\nã‚µã‚¤ã‚º: ${Math.round(byteLength / 1024)}KB\nã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³: ${animations.length > 0 ? 'ã‚ã‚Š' : 'ãªã—'}\n\nã€palanARã§ã®ä½¿ç”¨ã€‘\n1. https://planar.jp/ ã«ã‚¢ã‚¯ã‚»ã‚¹\n2. ã€ŒARãƒãƒ¼ã‚«ãƒ¼ä½œæˆã€ã‹ã‚‰ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰\n${!isBinary ? '3. ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãã®ã¾ã¾ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰\n4. palanARãŒè‡ªå‹•çš„ã«å±•é–‹ã—ã¾ã™' : ''}\n\n${isIOS && isBinary ? 'â€»iPadOS 18ã§GLBãŒé¸æŠã§ããªã„å ´åˆã¯\nZIPä¿å­˜ã‚’ãŠè©¦ã—ãã ã•ã„' : ''}`);
                            
                        } catch (error) {
                            console.error('Download error:', error);
                            alert('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
                            exportBtn.disabled = false;
                            exportBtn.textContent = isBinary ? 'ğŸ’¾ GLBä¿å­˜' : 'ğŸ’¾ ZIPä¿å­˜ (iPadOSæ¨å¥¨)';
                        }
                    },
                    function (error) {
                        console.error('Export error:', error);
                        alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
                        exportBtn.disabled = false;
                        exportBtn.textContent = isBinary ? 'ğŸ’¾ GLBä¿å­˜' : 'ğŸ’¾ ZIPä¿å­˜ (iPadOSæ¨å¥¨)';
                    },
                    exportOptions
                );
            } catch (error) {
                console.error('Preparation error:', error);
                alert('æº–å‚™ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
                exportBtn.disabled = false;
                exportBtn.textContent = isBinary ? 'ğŸ’¾ GLBä¿å­˜' : 'ğŸ’¾ ZIPä¿å­˜ (iPadOSæ¨å¥¨)';
            }
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('shape').addEventListener('change', updateMesh);
        document.getElementById('color').addEventListener('input', updateMesh);
        document.getElementById('applyColorToImported').addEventListener('change', updateMesh);
        document.getElementById('animation').addEventListener('change', updateAnimation);
        document.getElementById('size').addEventListener('input', function() {
            document.getElementById('sizeValue').textContent = this.value;
            updateMesh();
        });
        document.getElementById('speed').addEventListener('input', function() {
            document.getElementById('speedValue').textContent = parseFloat(this.value).toFixed(1);
            updateAnimation();
        });

        // ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('scaleX').addEventListener('input', function() {
            document.getElementById('scaleXValue').textContent = this.value;
            updateMesh();
        });
        document.getElementById('scaleY').addEventListener('input', function() {
            document.getElementById('scaleYValue').textContent = this.value;
            updateMesh();
        });
        document.getElementById('scaleZ').addEventListener('input', function() {
            document.getElementById('scaleZValue').textContent = this.value;
            updateMesh();
        });

        // GLBã‚¤ãƒ³ãƒãƒ¼ãƒˆã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('glbImport').addEventListener('change', async function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                const loader = new GLTFLoader();
                
                loader.parse(arrayBuffer, '', function(gltf) {
                    console.log('GLB loaded:', gltf);
                    console.log('Scene structure:', {
                        childrenCount: gltf.scene.children.length,
                        sceneType: gltf.scene.type,
                        children: gltf.scene.children.map(c => ({
                            name: c.name,
                            type: c.type,
                            childrenCount: c.children ? c.children.length : 0
                        }))
                    });
                    
                    // ã‚·ãƒ¼ãƒ³å…¨ä½“ã‚’ä¿æŒï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚„ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’å«ã‚€ï¼‰
                    importedModel = gltf.scene;
                    
                    // ãƒ¡ãƒƒã‚·ãƒ¥ã‚’æ›´æ–°
                    updateMesh();
                    
                    alert('âœ… GLBãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼\nã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚¹ã‚±ãƒ¼ãƒ«ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚\nè‰²ã®å¤‰æ›´ã¯å…ƒã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒå¤±ã‚ã‚Œã¾ã™ã€‚');
                }, function(error) {
                    console.error('GLB loading error:', error);
                    alert('âŒ ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                });
            };
            
            reader.readAsArrayBuffer(file);
        });

        // ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('clearImport').addEventListener('click', function() {
            importedModel = null;
            document.getElementById('glbImport').value = '';
            document.getElementById('applyColorToImported').checked = false;
            updateMesh();
            alert('âœ… ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚');
        });

        // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('exportBtn').addEventListener('click', () => exportGLB('glb'));
        document.getElementById('exportZipBtn').addEventListener('click', () => exportGLB('gltf'));

        // ãƒ—ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const presetIndex = parseInt(this.dataset.preset);
                const preset = presets[presetIndex];
                
                document.getElementById('shape').value = preset.shape;
                document.getElementById('color').value = preset.color;
                document.getElementById('animation').value = preset.animation;
                
                // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
                document.getElementById('scaleX').value = 1;
                document.getElementById('scaleY').value = 1;
                document.getElementById('scaleZ').value = 1;
                document.getElementById('scaleXValue').textContent = '1.0';
                document.getElementById('scaleYValue').textContent = '1.0';
                document.getElementById('scaleZValue').textContent = '1.0';
                
                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                updateMesh();
            });
        });

        // åˆæœŸåŒ–å®Ÿè¡Œ
        init();
    </script>
</body>
</html>
